{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"validators - Python Data Validation for Humans\u2122","text":"<p>Python has all kinds of data validation tools, but every one of them seems to require defining a schema or form. I wanted to create a simple validation library where validating a simple value does not require defining a form or a schema.</p> <pre><code>pip install validators\n</code></pre> <p>Then,</p> <pre><code>&gt;&gt;&gt; import validators\n&gt;&gt;&gt;\n&gt;&gt;&gt; validators.email('someone@example.com')\nTrue\n</code></pre>"},{"location":"#resources","title":"Resources","text":"<ul> <li>Documentation</li> <li>Bugtracker</li> <li>Security</li> <li>Code</li> </ul> <p>Python 3.9 reaches EOL in October 2025.</p>"},{"location":"install_and_use/","title":"Install and Use","text":""},{"location":"install_and_use/#installation","title":"Installation","text":"<p>Execute the following command:</p> <pre><code>pip install validators\n</code></pre> <p>It's preferable to use <code>pip</code> within a virtual environment.</p>"},{"location":"install_and_use/#usage","title":"Usage","text":"<pre><code>import validators\nprint(validators.email('someone@example.com'))\n</code></pre>"},{"location":"install_and_use/#to-raise-validation-error","title":"To raise validation error","text":"<ol> <li> <p>Either set the environment variable <code>RAISE_VALIDATION_ERROR</code> to <code>True</code></p> <pre><code>$ export RAISE_VALIDATION_ERROR=True\n$ python -c \"from validators import url; print(url('https//bad_url'))\"\nTraceback (most recent call last):\nFile \"&lt;string&gt;\", line 1, in &lt;module&gt;\nFile \"/path/to/lib/validators/utils.py\", line 87, in wrapper\n    raise ValidationError(func, _func_args_as_dict(func, *args, **kwargs))\nvalidators.utils.ValidationError: ValidationError(func=url, args={'value': 'https//bad_url'})\n</code></pre> </li> <li> <p>Or pass <code>r_ve=True</code> to each caller function:</p> <pre><code>$ python -c \"from validators.card import visa; print(visa('bad_visa_number', r_ve=True))\"\nTraceback (most recent call last):\nFile \"&lt;string&gt;\", line 1, in &lt;module&gt;\nFile \"/path/to/lib/validators/utils.py\", line 87, in wrapper\n    raise ValidationError(func, _func_args_as_dict(func, *args, **kwargs))\nvalidators.utils.ValidationError: ValidationError(func=visa, args={'value': 'bad_visa_number'})\n</code></pre> </li> </ol>"},{"location":"api/between/","title":"between","text":""},{"location":"api/between/#validators.between.between","title":"<code>validators.between.between(value, /, *, min_val=None, max_val=None)</code>","text":"<p>Validate that a number is between minimum and/or maximum value.</p> <p>This will work with any comparable type, such as floats, decimals and dates not just integers. This validator is originally based on WTForms-NumberRange-Validator.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; between(5, min_val=2)\nTrue\n&gt;&gt;&gt; between(13.2, min_val=13, max_val=14)\nTrue\n&gt;&gt;&gt; between(500, max_val=400)\nValidationError(func=between, args={'value': 500, 'max_val': 400})\n&gt;&gt;&gt; between(\n...     datetime(2000, 11, 11),\n...     min_val=datetime(1999, 11, 11)\n... )\nTrue\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>PossibleValueTypes</code> <p>Value which is to be compared.</p> required <code>min_val</code> <code>Union[PossibleValueTypes, AbsMin, None]</code> <p>The minimum required value of the number. If not provided, minimum value will not be checked.</p> <code>None</code> <code>max_val</code> <code>Union[PossibleValueTypes, AbsMax, None]</code> <p>The maximum value of the number. If not provided, maximum value will not be checked.</p> <code>None</code> <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is in between the given conditions.</p> <code>ValidationError</code> <p>If <code>value</code> is not in between the given conditions.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>min_val</code> is greater than <code>max_val</code>.</p> <code>TypeError</code> <p>If there's a type mismatch during comparison.</p> Note <ul> <li><code>PossibleValueTypes</code> = <code>TypeVar(\"PossibleValueTypes\", int, float, str, datetime)</code></li> <li>If neither <code>min_val</code> nor <code>max_val</code> is provided, result will always be <code>True</code>.</li> </ul> Source code in <code>src/validators/between.py</code> <pre><code>@validator\ndef between(\n    value: PossibleValueTypes,\n    /,\n    *,\n    min_val: Union[PossibleValueTypes, AbsMin, None] = None,\n    max_val: Union[PossibleValueTypes, AbsMax, None] = None,\n):\n    \"\"\"Validate that a number is between minimum and/or maximum value.\n\n    This will work with any comparable type, such as floats, decimals and dates\n    not just integers. This validator is originally based on [WTForms-NumberRange-Validator][1].\n\n    [1]: https://github.com/wtforms/wtforms/blob/master/src/wtforms/validators.py#L166-L220\n\n    Examples:\n        &gt;&gt;&gt; from datetime import datetime\n        &gt;&gt;&gt; between(5, min_val=2)\n        True\n        &gt;&gt;&gt; between(13.2, min_val=13, max_val=14)\n        True\n        &gt;&gt;&gt; between(500, max_val=400)\n        ValidationError(func=between, args={'value': 500, 'max_val': 400})\n        &gt;&gt;&gt; between(\n        ...     datetime(2000, 11, 11),\n        ...     min_val=datetime(1999, 11, 11)\n        ... )\n        True\n\n    Args:\n        value:\n            Value which is to be compared.\n        min_val:\n            The minimum required value of the number.\n            If not provided, minimum value will not be checked.\n        max_val:\n            The maximum value of the number.\n            If not provided, maximum value will not be checked.\n\n    Returns:\n        (Literal[True]): If `value` is in between the given conditions.\n        (ValidationError): If `value` is not in between the given conditions.\n\n    Raises:\n        (ValueError): If `min_val` is greater than `max_val`.\n        (TypeError): If there's a type mismatch during comparison.\n\n    Note:\n        - `PossibleValueTypes` = `TypeVar(\"PossibleValueTypes\", int, float, str, datetime)`\n        - If neither `min_val` nor `max_val` is provided, result will always be `True`.\n    \"\"\"\n    if value is None:\n        return False\n\n    if max_val is None:\n        max_val = AbsMax()\n    if min_val is None:\n        min_val = AbsMin()\n\n    try:\n        if min_val &gt; max_val:\n            raise ValueError(\"`min_val` cannot be greater than `max_val`\")\n    except TypeError as err:\n        raise TypeError(\"Comparison type mismatch\") from err\n\n    return min_val &lt;= value &lt;= max_val\n</code></pre>"},{"location":"api/card/","title":"card","text":""},{"location":"api/card/#validators.card.amex","title":"<code>validators.card.amex(value)</code>","text":"<p>Return whether or not given value is a valid American Express card number.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; amex('378282246310005')\nTrue\n&gt;&gt;&gt; amex('4242424242424242')\nValidationError(func=amex, args={'value': '4242424242424242'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>American Express card number string to validate</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid American Express card number.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid American Express card number.</p> Source code in <code>src/validators/card.py</code> <pre><code>@validator\ndef amex(value: str, /):\n    \"\"\"Return whether or not given value is a valid American Express card number.\n\n    Examples:\n        &gt;&gt;&gt; amex('378282246310005')\n        True\n        &gt;&gt;&gt; amex('4242424242424242')\n        ValidationError(func=amex, args={'value': '4242424242424242'})\n\n    Args:\n        value:\n            American Express card number string to validate\n\n    Returns:\n        (Literal[True]): If `value` is a valid American Express card number.\n        (ValidationError): If `value` is an invalid American Express card number.\n    \"\"\"\n    pattern = re.compile(r\"^(34|37)\")\n    return card_number(value) and len(value) == 15 and pattern.match(value)\n</code></pre>"},{"location":"api/card/#validators.card.card_number","title":"<code>validators.card.card_number(value)</code>","text":"<p>Return whether or not given value is a valid generic card number.</p> <p>This validator is based on Luhn's algorithm.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; card_number('4242424242424242')\nTrue\n&gt;&gt;&gt; card_number('4242424242424241')\nValidationError(func=card_number, args={'value': '4242424242424241'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Generic card number string to validate</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid generic card number.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid generic card number.</p> Source code in <code>src/validators/card.py</code> <pre><code>@validator\ndef card_number(value: str, /):\n    \"\"\"Return whether or not given value is a valid generic card number.\n\n    This validator is based on [Luhn's algorithm][1].\n\n    [1]: https://github.com/mmcloughlin/luhn\n\n    Examples:\n        &gt;&gt;&gt; card_number('4242424242424242')\n        True\n        &gt;&gt;&gt; card_number('4242424242424241')\n        ValidationError(func=card_number, args={'value': '4242424242424241'})\n\n    Args:\n        value:\n            Generic card number string to validate\n\n    Returns:\n        (Literal[True]): If `value` is a valid generic card number.\n        (ValidationError): If `value` is an invalid generic card number.\n    \"\"\"\n    if not value:\n        return False\n    try:\n        digits = list(map(int, value))\n        odd_sum = sum(digits[-1::-2])\n        even_sum = sum(sum(divmod(2 * d, 10)) for d in digits[-2::-2])\n        return (odd_sum + even_sum) % 10 == 0\n    except ValueError:\n        return False\n</code></pre>"},{"location":"api/card/#validators.card.diners","title":"<code>validators.card.diners(value)</code>","text":"<p>Return whether or not given value is a valid Diners Club card number.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; diners('3056930009020004')\nTrue\n&gt;&gt;&gt; diners('4242424242424242')\nValidationError(func=diners, args={'value': '4242424242424242'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Diners Club card number string to validate</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid Diners Club card number.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid Diners Club card number.</p> Source code in <code>src/validators/card.py</code> <pre><code>@validator\ndef diners(value: str, /):\n    \"\"\"Return whether or not given value is a valid Diners Club card number.\n\n    Examples:\n        &gt;&gt;&gt; diners('3056930009020004')\n        True\n        &gt;&gt;&gt; diners('4242424242424242')\n        ValidationError(func=diners, args={'value': '4242424242424242'})\n\n    Args:\n        value:\n            Diners Club card number string to validate\n\n    Returns:\n        (Literal[True]): If `value` is a valid Diners Club card number.\n        (ValidationError): If `value` is an invalid Diners Club card number.\n    \"\"\"\n    pattern = re.compile(r\"^(30|36|38|39)\")\n    return card_number(value) and len(value) in {14, 16} and pattern.match(value)\n</code></pre>"},{"location":"api/card/#validators.card.discover","title":"<code>validators.card.discover(value)</code>","text":"<p>Return whether or not given value is a valid Discover card number.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; discover('6011111111111117')\nTrue\n&gt;&gt;&gt; discover('4242424242424242')\nValidationError(func=discover, args={'value': '4242424242424242'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Discover card number string to validate</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid Discover card number.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid Discover card number.</p> Source code in <code>src/validators/card.py</code> <pre><code>@validator\ndef discover(value: str, /):\n    \"\"\"Return whether or not given value is a valid Discover card number.\n\n    Examples:\n        &gt;&gt;&gt; discover('6011111111111117')\n        True\n        &gt;&gt;&gt; discover('4242424242424242')\n        ValidationError(func=discover, args={'value': '4242424242424242'})\n\n    Args:\n        value:\n            Discover card number string to validate\n\n    Returns:\n        (Literal[True]): If `value` is a valid Discover card number.\n        (ValidationError): If `value` is an invalid Discover card number.\n    \"\"\"\n    pattern = re.compile(r\"^(60|64|65)\")\n    return card_number(value) and len(value) == 16 and pattern.match(value)\n</code></pre>"},{"location":"api/card/#validators.card.jcb","title":"<code>validators.card.jcb(value)</code>","text":"<p>Return whether or not given value is a valid JCB card number.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; jcb('3566002020360505')\nTrue\n&gt;&gt;&gt; jcb('4242424242424242')\nValidationError(func=jcb, args={'value': '4242424242424242'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>JCB card number string to validate</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid JCB card number.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid JCB card number.</p> Source code in <code>src/validators/card.py</code> <pre><code>@validator\ndef jcb(value: str, /):\n    \"\"\"Return whether or not given value is a valid JCB card number.\n\n    Examples:\n        &gt;&gt;&gt; jcb('3566002020360505')\n        True\n        &gt;&gt;&gt; jcb('4242424242424242')\n        ValidationError(func=jcb, args={'value': '4242424242424242'})\n\n    Args:\n        value:\n            JCB card number string to validate\n\n    Returns:\n        (Literal[True]): If `value` is a valid JCB card number.\n        (ValidationError): If `value` is an invalid JCB card number.\n    \"\"\"\n    pattern = re.compile(r\"^35\")\n    return card_number(value) and len(value) == 16 and pattern.match(value)\n</code></pre>"},{"location":"api/card/#validators.card.mastercard","title":"<code>validators.card.mastercard(value)</code>","text":"<p>Return whether or not given value is a valid Mastercard card number.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; mastercard('5555555555554444')\nTrue\n&gt;&gt;&gt; mastercard('4242424242424242')\nValidationError(func=mastercard, args={'value': '4242424242424242'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Mastercard card number string to validate</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid Mastercard card number.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid Mastercard card number.</p> Source code in <code>src/validators/card.py</code> <pre><code>@validator\ndef mastercard(value: str, /):\n    \"\"\"Return whether or not given value is a valid Mastercard card number.\n\n    Examples:\n        &gt;&gt;&gt; mastercard('5555555555554444')\n        True\n        &gt;&gt;&gt; mastercard('4242424242424242')\n        ValidationError(func=mastercard, args={'value': '4242424242424242'})\n\n    Args:\n        value:\n            Mastercard card number string to validate\n\n    Returns:\n        (Literal[True]): If `value` is a valid Mastercard card number.\n        (ValidationError): If `value` is an invalid Mastercard card number.\n    \"\"\"\n    pattern = re.compile(r\"^(51|52|53|54|55|22|23|24|25|26|27)\")\n    return card_number(value) and len(value) == 16 and pattern.match(value)\n</code></pre>"},{"location":"api/card/#validators.card.mir","title":"<code>validators.card.mir(value)</code>","text":"<p>Return whether or not given value is a valid Mir card number.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; mir('2200123456789019')\nTrue\n&gt;&gt;&gt; mir('4242424242424242')\nValidationError(func=mir, args={'value': '4242424242424242'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Mir card number string to validate.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid Mir card number.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid Mir card number.</p> Source code in <code>src/validators/card.py</code> <pre><code>@validator\ndef mir(value: str, /):\n    \"\"\"Return whether or not given value is a valid Mir card number.\n\n    Examples:\n        &gt;&gt;&gt; mir('2200123456789019')\n        True\n        &gt;&gt;&gt; mir('4242424242424242')\n        ValidationError(func=mir, args={'value': '4242424242424242'})\n\n    Args:\n        value:\n            Mir card number string to validate.\n\n    Returns:\n        (Literal[True]): If `value` is a valid Mir card number.\n        (ValidationError): If `value` is an invalid Mir card number.\n    \"\"\"\n    pattern = re.compile(r\"^(220[0-4])\")\n    return card_number(value) and len(value) == 16 and pattern.match(value)\n</code></pre>"},{"location":"api/card/#validators.card.unionpay","title":"<code>validators.card.unionpay(value)</code>","text":"<p>Return whether or not given value is a valid UnionPay card number.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; unionpay('6200000000000005')\nTrue\n&gt;&gt;&gt; unionpay('4242424242424242')\nValidationError(func=unionpay, args={'value': '4242424242424242'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>UnionPay card number string to validate</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid UnionPay card number.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid UnionPay card number.</p> Source code in <code>src/validators/card.py</code> <pre><code>@validator\ndef unionpay(value: str, /):\n    \"\"\"Return whether or not given value is a valid UnionPay card number.\n\n    Examples:\n        &gt;&gt;&gt; unionpay('6200000000000005')\n        True\n        &gt;&gt;&gt; unionpay('4242424242424242')\n        ValidationError(func=unionpay, args={'value': '4242424242424242'})\n\n    Args:\n        value:\n            UnionPay card number string to validate\n\n    Returns:\n        (Literal[True]): If `value` is a valid UnionPay card number.\n        (ValidationError): If `value` is an invalid UnionPay card number.\n    \"\"\"\n    pattern = re.compile(r\"^62\")\n    return card_number(value) and len(value) == 16 and pattern.match(value)\n</code></pre>"},{"location":"api/card/#validators.card.visa","title":"<code>validators.card.visa(value)</code>","text":"<p>Return whether or not given value is a valid Visa card number.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; visa('4242424242424242')\nTrue\n&gt;&gt;&gt; visa('2223003122003222')\nValidationError(func=visa, args={'value': '2223003122003222'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Visa card number string to validate</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid Visa card number.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid Visa card number.</p> Source code in <code>src/validators/card.py</code> <pre><code>@validator\ndef visa(value: str, /):\n    \"\"\"Return whether or not given value is a valid Visa card number.\n\n    Examples:\n        &gt;&gt;&gt; visa('4242424242424242')\n        True\n        &gt;&gt;&gt; visa('2223003122003222')\n        ValidationError(func=visa, args={'value': '2223003122003222'})\n\n    Args:\n        value:\n            Visa card number string to validate\n\n    Returns:\n        (Literal[True]): If `value` is a valid Visa card number.\n        (ValidationError): If `value` is an invalid Visa card number.\n    \"\"\"\n    pattern = re.compile(r\"^4\")\n    return card_number(value) and len(value) == 16 and pattern.match(value)\n</code></pre>"},{"location":"api/country/","title":"country","text":""},{"location":"api/country/#validators.country.calling_code","title":"<code>validators.country.calling_code(value)</code>","text":"<p>Validates given calling code.</p> <p>This performs country's calling code validation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; calling_code('+91')\nTrue\n&gt;&gt;&gt; calling_code('-31')\nValidationError(func=calling_code, args={'value': '-31'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Country's calling code string to validate.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid calling code.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid calling code.</p> Source code in <code>src/validators/country.py</code> <pre><code>@validator\ndef calling_code(value: str, /):\n    \"\"\"Validates given calling code.\n\n    This performs country's calling code validation.\n\n    Examples:\n        &gt;&gt;&gt; calling_code('+91')\n        True\n        &gt;&gt;&gt; calling_code('-31')\n        ValidationError(func=calling_code, args={'value': '-31'})\n\n    Args:\n        value:\n            Country's calling code string to validate.\n\n    Returns:\n        (Literal[True]): If `value` is a valid calling code.\n        (ValidationError): If `value` is an invalid calling code.\n    \"\"\"\n    if not value:\n        return False\n\n    return value in set(_calling_codes.values())\n</code></pre>"},{"location":"api/country/#validators.country.country_code","title":"<code>validators.country.country_code(value, /, *, iso_format='auto', ignore_case=False)</code>","text":"<p>Validates given country code.</p> <p>This performs a case-sensitive ISO 3166 country code validation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; country_code('GB', iso_format='alpha3')\nValidationError(func=country_code, args={'value': 'GB', 'iso_format': 'alpha3'})\n&gt;&gt;&gt; country_code('USA')\nTrue\n&gt;&gt;&gt; country_code('840', iso_format='numeric')\nTrue\n&gt;&gt;&gt; country_code('iN', iso_format='alpha2')\nValidationError(func=country_code, args={'value': 'iN', 'iso_format': 'alpha2'})\n&gt;&gt;&gt; country_code('ZWE', iso_format='alpha3')\nTrue\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Country code string to validate.</p> required <code>iso_format</code> <code>str</code> <p>ISO format to be used. Available options are: <code>auto</code>, <code>alpha2</code>, <code>alpha3</code> and <code>numeric</code>.</p> <code>'auto'</code> <code>ignore_case</code> <code>bool</code> <p>Enable/Disable case-sensitive matching.</p> <code>False</code> <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid country code.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid country code.</p> Source code in <code>src/validators/country.py</code> <pre><code>@validator\ndef country_code(value: str, /, *, iso_format: str = \"auto\", ignore_case: bool = False):\n    \"\"\"Validates given country code.\n\n    This performs a case-sensitive [ISO 3166][1] country code validation.\n\n    [1]: https://www.iso.org/iso-3166-country-codes.html\n\n    Examples:\n        &gt;&gt;&gt; country_code('GB', iso_format='alpha3')\n        ValidationError(func=country_code, args={'value': 'GB', 'iso_format': 'alpha3'})\n        &gt;&gt;&gt; country_code('USA')\n        True\n        &gt;&gt;&gt; country_code('840', iso_format='numeric')\n        True\n        &gt;&gt;&gt; country_code('iN', iso_format='alpha2')\n        ValidationError(func=country_code, args={'value': 'iN', 'iso_format': 'alpha2'})\n        &gt;&gt;&gt; country_code('ZWE', iso_format='alpha3')\n        True\n\n    Args:\n        value:\n            Country code string to validate.\n        iso_format:\n            ISO format to be used. Available options are:\n            `auto`, `alpha2`, `alpha3` and `numeric`.\n        ignore_case:\n            Enable/Disable case-sensitive matching.\n\n    Returns:\n        (Literal[True]): If `value` is a valid country code.\n        (ValidationError): If `value` is an invalid country code.\n    \"\"\"\n    if not value:\n        return False\n\n    if not (1 &lt; len(value) &lt; 4):\n        return False\n\n    if iso_format == \"auto\" and (iso_format := _get_code_type(value)) == \"invalid\":\n        return False\n\n    if iso_format == \"alpha2\":\n        return (\n            value.upper() in set(_alpha3_to_alpha2.values())\n            if ignore_case\n            else value in set(_alpha3_to_alpha2.values())\n        )\n    if iso_format == \"alpha3\":\n        return value.upper() in _alpha3_to_alpha2 if ignore_case else value in _alpha3_to_alpha2\n\n    return value in _numeric if iso_format == \"numeric\" else False\n</code></pre>"},{"location":"api/country/#validators.country.currency","title":"<code>validators.country.currency(value, /, *, skip_symbols=True, ignore_case=False)</code>","text":"<p>Validates given currency code.</p> <p>This performs ISO 4217 currency code/symbol validation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; currency('USD')\nTrue\n&gt;&gt;&gt; currency('ZWX')\nValidationError(func=currency, args={'value': 'ZWX'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Currency code/symbol string to validate.</p> required <code>skip_symbols</code> <code>bool</code> <p>Skip currency symbol validation.</p> <code>True</code> <code>ignore_case</code> <code>bool</code> <p>Enable/Disable case-sensitive matching.</p> <code>False</code> <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid currency code.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid currency code.</p> Source code in <code>src/validators/country.py</code> <pre><code>@validator\ndef currency(value: str, /, *, skip_symbols: bool = True, ignore_case: bool = False):\n    \"\"\"Validates given currency code.\n\n    This performs [ISO 4217][1] currency code/symbol validation.\n\n    [1]: https://www.iso.org/iso-4217-currency-codes.html\n\n    Examples:\n        &gt;&gt;&gt; currency('USD')\n        True\n        &gt;&gt;&gt; currency('ZWX')\n        ValidationError(func=currency, args={'value': 'ZWX'})\n\n    Args:\n        value:\n            Currency code/symbol string to validate.\n        skip_symbols:\n            Skip currency symbol validation.\n        ignore_case:\n            Enable/Disable case-sensitive matching.\n\n    Returns:\n        (Literal[True]): If `value` is a valid currency code.\n        (ValidationError): If `value` is an invalid currency code.\n    \"\"\"\n    if not value:\n        return False\n\n    if not skip_symbols and value in _currency_symbols:\n        return True\n\n    if len(value) != 3:\n        return False\n\n    return value.upper() in _currency_iso4217 if ignore_case else value in _currency_iso4217\n</code></pre>"},{"location":"api/cron/","title":"cron","text":""},{"location":"api/cron/#validators.cron.cron","title":"<code>validators.cron.cron(value)</code>","text":"<p>Return whether or not given value is a valid cron string.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cron('*/5 * * * *')\nTrue\n&gt;&gt;&gt; cron('30-20 * * * *')\nValidationError(func=cron, args={'value': '30-20 * * * *'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Cron string to validate.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid cron string.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid cron string.</p> Source code in <code>src/validators/cron.py</code> <pre><code>@validator\ndef cron(value: str, /):\n    \"\"\"Return whether or not given value is a valid cron string.\n\n    Examples:\n        &gt;&gt;&gt; cron('*/5 * * * *')\n        True\n        &gt;&gt;&gt; cron('30-20 * * * *')\n        ValidationError(func=cron, args={'value': '30-20 * * * *'})\n\n    Args:\n        value:\n            Cron string to validate.\n\n    Returns:\n        (Literal[True]): If `value` is a valid cron string.\n        (ValidationError): If `value` is an invalid cron string.\n    \"\"\"\n    if not value:\n        return False\n\n    try:\n        minutes, hours, days, months, weekdays = value.strip().split()\n    except ValueError as err:\n        raise ValueError(\"Badly formatted cron string\") from err\n\n    if not _validate_cron_component(minutes, 0, 59):\n        return False\n    if not _validate_cron_component(hours, 0, 23):\n        return False\n    if not _validate_cron_component(days, 1, 31):\n        return False\n    if not _validate_cron_component(months, 1, 12):\n        return False\n    if not _validate_cron_component(weekdays, 0, 6):\n        return False\n\n    return True\n</code></pre>"},{"location":"api/crypto_addresses/","title":"crypto_addresses","text":""},{"location":"api/crypto_addresses/#validators.crypto_addresses.bsc_address","title":"<code>validators.crypto_addresses.bsc_address</code>","text":"<p>BSC Address.</p>"},{"location":"api/crypto_addresses/#validators.crypto_addresses.bsc_address.bsc_address","title":"<code>bsc_address(value)</code>","text":"<p>Return whether or not given value is a valid binance smart chain address.</p> <p>Full validation is implemented for BSC addresses.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; bsc_address('0x4e5acf9684652BEa56F2f01b7101a225Ee33d23f')\nTrue\n&gt;&gt;&gt; bsc_address('0x4g5acf9684652BEa56F2f01b7101a225Eh33d23z')\nValidationError(func=bsc_address, args={'value': '0x4g5acf9684652BEa56F2f01b7101a225Eh33d23z'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>BSC address string to validate.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid bsc address.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid bsc address.</p> Source code in <code>src/validators/crypto_addresses/bsc_address.py</code> <pre><code>@validator\ndef bsc_address(value: str, /):\n    \"\"\"Return whether or not given value is a valid binance smart chain address.\n\n    Full validation is implemented for BSC addresses.\n\n    Examples:\n        &gt;&gt;&gt; bsc_address('0x4e5acf9684652BEa56F2f01b7101a225Ee33d23f')\n        True\n        &gt;&gt;&gt; bsc_address('0x4g5acf9684652BEa56F2f01b7101a225Eh33d23z')\n        ValidationError(func=bsc_address, args={'value': '0x4g5acf9684652BEa56F2f01b7101a225Eh33d23z'})\n\n    Args:\n        value:\n            BSC address string to validate.\n\n    Returns:\n        (Literal[True]): If `value` is a valid bsc address.\n        (ValidationError): If `value` is an invalid bsc address.\n    \"\"\"  # noqa: E501\n    if not value:\n        return False\n\n    if not re.fullmatch(r\"0x[a-fA-F0-9]{40}\", value):\n        return False\n\n    return True\n</code></pre>"},{"location":"api/crypto_addresses/#validators.crypto_addresses.btc_address","title":"<code>validators.crypto_addresses.btc_address</code>","text":"<p>BTC Address.</p>"},{"location":"api/crypto_addresses/#validators.crypto_addresses.btc_address.btc_address","title":"<code>btc_address(value)</code>","text":"<p>Return whether or not given value is a valid bitcoin address.</p> <p>Full validation is implemented for P2PKH and P2SH addresses. For segwit addresses a regexp is used to provide a reasonable estimate on whether the address is valid.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; btc_address('3Cwgr2g7vsi1bXDUkpEnVoRLA9w4FZfC69')\nTrue\n&gt;&gt;&gt; btc_address('1BvBMsEYstWetqTFn5Au4m4GFg7xJaNVN2')\nValidationError(func=btc_address, args={'value': '1BvBMsEYstWetqTFn5Au4m4GFg7xJaNVN2'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Bitcoin address string to validate.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid bitcoin address.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid bitcoin address.</p> Source code in <code>src/validators/crypto_addresses/btc_address.py</code> <pre><code>@validator\ndef btc_address(value: str, /):\n    \"\"\"Return whether or not given value is a valid bitcoin address.\n\n    Full validation is implemented for P2PKH and P2SH addresses.\n    For segwit addresses a regexp is used to provide a reasonable\n    estimate on whether the address is valid.\n\n    Examples:\n        &gt;&gt;&gt; btc_address('3Cwgr2g7vsi1bXDUkpEnVoRLA9w4FZfC69')\n        True\n        &gt;&gt;&gt; btc_address('1BvBMsEYstWetqTFn5Au4m4GFg7xJaNVN2')\n        ValidationError(func=btc_address, args={'value': '1BvBMsEYstWetqTFn5Au4m4GFg7xJaNVN2'})\n\n    Args:\n        value:\n            Bitcoin address string to validate.\n\n    Returns:\n        (Literal[True]): If `value` is a valid bitcoin address.\n        (ValidationError): If `value` is an invalid bitcoin address.\n    \"\"\"\n    if not value:\n        return False\n\n    return (\n        # segwit pattern\n        re.compile(r\"^(bc|tc)[0-3][02-9ac-hj-np-z]{14,74}$\").match(value)\n        if value[:2] in (\"bc\", \"tb\")\n        else _validate_old_btc_address(value)\n    )\n</code></pre>"},{"location":"api/crypto_addresses/#validators.crypto_addresses.eth_address","title":"<code>validators.crypto_addresses.eth_address</code>","text":"<p>ETH Address.</p>"},{"location":"api/crypto_addresses/#validators.crypto_addresses.eth_address.eth_address","title":"<code>eth_address(value)</code>","text":"<p>Return whether or not given value is a valid ethereum address.</p> <p>Full validation is implemented for ERC20 addresses.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; eth_address('0x9cc14ba4f9f68ca159ea4ebf2c292a808aaeb598')\nTrue\n&gt;&gt;&gt; eth_address('0x8Ba1f109551bD432803012645Ac136ddd64DBa72')\nValidationError(func=eth_address, args={'value': '0x8Ba1f109551bD432803012645Ac136ddd64DBa72'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Ethereum address string to validate.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid ethereum address.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid ethereum address.</p> Source code in <code>src/validators/crypto_addresses/eth_address.py</code> <pre><code>@validator\ndef eth_address(value: str, /):\n    \"\"\"Return whether or not given value is a valid ethereum address.\n\n    Full validation is implemented for ERC20 addresses.\n\n    Examples:\n        &gt;&gt;&gt; eth_address('0x9cc14ba4f9f68ca159ea4ebf2c292a808aaeb598')\n        True\n        &gt;&gt;&gt; eth_address('0x8Ba1f109551bD432803012645Ac136ddd64DBa72')\n        ValidationError(func=eth_address, args={'value': '0x8Ba1f109551bD432803012645Ac136ddd64DBa72'})\n\n    Args:\n        value:\n            Ethereum address string to validate.\n\n    Returns:\n        (Literal[True]): If `value` is a valid ethereum address.\n        (ValidationError): If `value` is an invalid ethereum address.\n    \"\"\"  # noqa: E501\n    if not _keccak_flag:\n        raise ImportError(\n            \"Do `pip install validators[crypto-eth-addresses]` to perform `eth_address` validation.\"\n        )\n\n    if not value:\n        return False\n\n    return re.compile(r\"^0x[0-9a-f]{40}$|^0x[0-9A-F]{40}$\").match(\n        value\n    ) or _validate_eth_checksum_address(value)\n</code></pre>"},{"location":"api/crypto_addresses/#validators.crypto_addresses.trx_address","title":"<code>validators.crypto_addresses.trx_address</code>","text":"<p>TRX Address.</p>"},{"location":"api/crypto_addresses/#validators.crypto_addresses.trx_address.trx_address","title":"<code>trx_address(value)</code>","text":"<p>Return whether or not given value is a valid tron address.</p> <p>Full validation is implemented for TRC20 tron addresses.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; trx_address('TLjfbTbpZYDQ4EoA4N5CLNgGjfbF8ZWz38')\nTrue\n&gt;&gt;&gt; trx_address('TR2G7Rm4vFqF8EpY4U5xdLdQ7XgJ2U8Vd')\nValidationError(func=trx_address, args={'value': 'TR2G7Rm4vFqF8EpY4U5xdLdQ7XgJ2U8Vd'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Tron address string to validate.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid tron address.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid tron address.</p> Source code in <code>src/validators/crypto_addresses/trx_address.py</code> <pre><code>@validator\ndef trx_address(value: str, /):\n    \"\"\"Return whether or not given value is a valid tron address.\n\n    Full validation is implemented for TRC20 tron addresses.\n\n    Examples:\n        &gt;&gt;&gt; trx_address('TLjfbTbpZYDQ4EoA4N5CLNgGjfbF8ZWz38')\n        True\n        &gt;&gt;&gt; trx_address('TR2G7Rm4vFqF8EpY4U5xdLdQ7XgJ2U8Vd')\n        ValidationError(func=trx_address, args={'value': 'TR2G7Rm4vFqF8EpY4U5xdLdQ7XgJ2U8Vd'})\n\n    Args:\n        value:\n            Tron address string to validate.\n\n    Returns:\n        (Literal[True]): If `value` is a valid tron address.\n        (ValidationError): If `value` is an invalid tron address.\n    \"\"\"\n    if not value:\n        return False\n\n    return re.compile(r\"^[T][a-km-zA-HJ-NP-Z1-9]{33}$\").match(\n        value\n    ) and _validate_trx_checksum_address(value)\n</code></pre>"},{"location":"api/domain/","title":"domain","text":""},{"location":"api/domain/#validators.domain.domain","title":"<code>validators.domain.domain(value, /, *, consider_tld=False, rfc_1034=False, rfc_2782=False)</code>","text":"<p>Return whether or not given value is a valid domain.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; domain('example.com')\nTrue\n&gt;&gt;&gt; domain('example.com/')\nValidationError(func=domain, args={'value': 'example.com/'})\n&gt;&gt;&gt; # Supports IDN domains as well::\n&gt;&gt;&gt; domain('xn----gtbspbbmkef.xn--p1ai')\nTrue\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Domain string to validate.</p> required <code>consider_tld</code> <code>bool</code> <p>Restrict domain to TLDs allowed by IANA.</p> <code>False</code> <code>rfc_1034</code> <code>bool</code> <p>Allows optional trailing dot in the domain name. Ref: RFC 1034.</p> <code>False</code> <code>rfc_2782</code> <code>bool</code> <p>Domain name is of type service record. Allows optional underscores in the domain name. Ref: RFC 2782.</p> <code>False</code> <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid domain name.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid domain name.</p> <p>Raises:</p> Type Description <code>UnicodeError</code> <p>If <code>value</code> cannot be encoded into <code>idna</code> or decoded into <code>utf-8</code>.</p> Source code in <code>src/validators/domain.py</code> <pre><code>@validator\ndef domain(\n    value: str, /, *, consider_tld: bool = False, rfc_1034: bool = False, rfc_2782: bool = False\n):\n    \"\"\"Return whether or not given value is a valid domain.\n\n    Examples:\n        &gt;&gt;&gt; domain('example.com')\n        True\n        &gt;&gt;&gt; domain('example.com/')\n        ValidationError(func=domain, args={'value': 'example.com/'})\n        &gt;&gt;&gt; # Supports IDN domains as well::\n        &gt;&gt;&gt; domain('xn----gtbspbbmkef.xn--p1ai')\n        True\n\n    Args:\n        value:\n            Domain string to validate.\n        consider_tld:\n            Restrict domain to TLDs allowed by IANA.\n        rfc_1034:\n            Allows optional trailing dot in the domain name.\n            Ref: [RFC 1034](https://www.rfc-editor.org/rfc/rfc1034).\n        rfc_2782:\n            Domain name is of type service record.\n            Allows optional underscores in the domain name.\n            Ref: [RFC 2782](https://www.rfc-editor.org/rfc/rfc2782).\n\n\n    Returns:\n        (Literal[True]): If `value` is a valid domain name.\n        (ValidationError): If `value` is an invalid domain name.\n\n    Raises:\n        (UnicodeError): If `value` cannot be encoded into `idna` or decoded into `utf-8`.\n    \"\"\"\n    if not value:\n        return False\n\n    if consider_tld and not _IanaTLD.check(value.rstrip(\".\").rsplit(\".\", 1)[-1].upper()):\n        return False\n\n    try:\n        service_record = r\"_\" if rfc_2782 else \"\"\n        trailing_dot = r\"\\.?$\" if rfc_1034 else r\"$\"\n\n        return not re.search(r\"\\s|__+\", value) and re.match(\n            # First character of the domain\n            rf\"^(?:[a-z0-9{service_record}]\"\n            # Sub-domain\n            + rf\"(?:[a-z0-9-{service_record}]{{0,61}}\"\n            # Hostname\n            + rf\"[a-z0-9{service_record}])?\\.)\"\n            # First 61 characters of the gTLD\n            + r\"+[a-z0-9][a-z0-9-_]{0,61}\"\n            # Last character of the gTLD\n            + rf\"[a-z]{trailing_dot}\",\n            value.encode(\"idna\").decode(\"utf-8\"),\n            re.IGNORECASE,\n        )\n    except UnicodeError as err:\n        raise UnicodeError(f\"Unable to encode/decode {value}\") from err\n</code></pre>"},{"location":"api/email/","title":"email","text":""},{"location":"api/email/#validators.email.email","title":"<code>validators.email.email(value, /, *, ipv6_address=False, ipv4_address=False, simple_host=False, rfc_1034=False, rfc_2782=False)</code>","text":"<p>Validate an email address.</p> <p>This was inspired from Django's email validator. Also ref: RFC 1034, RFC 5321 and RFC 5322.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; email('someone@example.com')\nTrue\n&gt;&gt;&gt; email('bogus@@')\nValidationError(func=email, args={'value': 'bogus@@'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>eMail string to validate.</p> required <code>ipv6_address</code> <code>bool</code> <p>When the domain part is an IPv6 address.</p> <code>False</code> <code>ipv4_address</code> <code>bool</code> <p>When the domain part is an IPv4 address.</p> <code>False</code> <code>simple_host</code> <code>bool</code> <p>When the domain part is a simple hostname.</p> <code>False</code> <code>rfc_1034</code> <code>bool</code> <p>Allow trailing dot in domain name. Ref: RFC 1034.</p> <code>False</code> <code>rfc_2782</code> <code>bool</code> <p>Domain name is of type service record. Ref: RFC 2782.</p> <code>False</code> <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid eMail.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid eMail.</p> Source code in <code>src/validators/email.py</code> <pre><code>@validator\ndef email(\n    value: str,\n    /,\n    *,\n    ipv6_address: bool = False,\n    ipv4_address: bool = False,\n    simple_host: bool = False,\n    rfc_1034: bool = False,\n    rfc_2782: bool = False,\n):\n    \"\"\"Validate an email address.\n\n    This was inspired from [Django's email validator][1].\n    Also ref: [RFC 1034][2], [RFC 5321][3] and [RFC 5322][4].\n\n    [1]: https://github.com/django/django/blob/main/django/core/validators.py#L174\n    [2]: https://www.rfc-editor.org/rfc/rfc1034\n    [3]: https://www.rfc-editor.org/rfc/rfc5321\n    [4]: https://www.rfc-editor.org/rfc/rfc5322\n\n    Examples:\n        &gt;&gt;&gt; email('someone@example.com')\n        True\n        &gt;&gt;&gt; email('bogus@@')\n        ValidationError(func=email, args={'value': 'bogus@@'})\n\n    Args:\n        value:\n            eMail string to validate.\n        ipv6_address:\n            When the domain part is an IPv6 address.\n        ipv4_address:\n            When the domain part is an IPv4 address.\n        simple_host:\n            When the domain part is a simple hostname.\n        rfc_1034:\n            Allow trailing dot in domain name.\n            Ref: [RFC 1034](https://www.rfc-editor.org/rfc/rfc1034).\n        rfc_2782:\n            Domain name is of type service record.\n            Ref: [RFC 2782](https://www.rfc-editor.org/rfc/rfc2782).\n\n    Returns:\n        (Literal[True]): If `value` is a valid eMail.\n        (ValidationError): If `value` is an invalid eMail.\n    \"\"\"\n    if not value or value.count(\"@\") != 1:\n        return False\n\n    username_part, domain_part = value.rsplit(\"@\", 1)\n\n    if len(username_part) &gt; 64 or len(domain_part) &gt; 253:\n        # ref: RFC 1034 and 5231\n        return False\n\n    if ipv6_address or ipv4_address:\n        if domain_part.startswith(\"[\") and domain_part.endswith(\"]\"):\n            # ref: RFC 5321\n            domain_part = domain_part.lstrip(\"[\").rstrip(\"]\")\n        else:\n            return False\n\n    return (\n        bool(\n            hostname(\n                domain_part,\n                skip_ipv6_addr=not ipv6_address,\n                skip_ipv4_addr=not ipv4_address,\n                may_have_port=False,\n                maybe_simple=simple_host,\n                rfc_1034=rfc_1034,\n                rfc_2782=rfc_2782,\n            )\n        )\n        if re.match(\n            # extended latin\n            r\"(^[\\u0100-\\u017F\\u0180-\\u024F\\u00A0-\\u00FF]\"\n            # dot-atom\n            + r\"|[\\u0100-\\u017F\\u0180-\\u024F\\u00A0-\\u00FF0-9a-z!#$%&amp;'*+/=?^_`{}|~\\-]+\"\n            + r\"(\\.[\\u0100-\\u017F\\u0180-\\u024F\\u00A0-\\u00FF0-9a-z!#$%&amp;'*+/=?^_`{}|~\\-]+)*$\"\n            # quoted-string\n            + r'|^\"('\n            + r\"[\\u0100-\\u017F\\u0180-\\u024F\\u00A0-\\u00FF\\001-\\010\\013\\014\\016-\\037\"\n            + r\"!#-\\[\\]-\\177]|\\\\[\\011.]\"\n            + r')*\")$',\n            username_part,\n            re.IGNORECASE,\n        )\n        else False\n    )\n</code></pre>"},{"location":"api/encoding/","title":"encoding","text":""},{"location":"api/encoding/#validators.encoding.base16","title":"<code>validators.encoding.base16(value)</code>","text":"<p>Return whether or not given value is a valid base16 encoding.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; base16('a3f4b2')\nTrue\n&gt;&gt;&gt; base16('a3f4Z1')\nValidationError(func=base16, args={'value': 'a3f4Z1'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>base16 string to validate.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid base16 encoding.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid base16 encoding.</p> Source code in <code>src/validators/encoding.py</code> <pre><code>@validator\ndef base16(value: str, /):\n    \"\"\"Return whether or not given value is a valid base16 encoding.\n\n    Examples:\n        &gt;&gt;&gt; base16('a3f4b2')\n        True\n        &gt;&gt;&gt; base16('a3f4Z1')\n        ValidationError(func=base16, args={'value': 'a3f4Z1'})\n\n    Args:\n        value:\n            base16 string to validate.\n\n    Returns:\n        (Literal[True]): If `value` is a valid base16 encoding.\n        (ValidationError): If `value` is an invalid base16 encoding.\n    \"\"\"\n    return re.match(r\"^[0-9A-Fa-f]+$\", value) if value else False\n</code></pre>"},{"location":"api/encoding/#validators.encoding.base32","title":"<code>validators.encoding.base32(value)</code>","text":"<p>Return whether or not given value is a valid base32 encoding.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; base32('MFZWIZLTOQ======')\nTrue\n&gt;&gt;&gt; base32('MfZW3zLT9Q======')\nValidationError(func=base32, args={'value': 'MfZW3zLT9Q======'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>base32 string to validate.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid base32 encoding.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid base32 encoding.</p> Source code in <code>src/validators/encoding.py</code> <pre><code>@validator\ndef base32(value: str, /):\n    \"\"\"Return whether or not given value is a valid base32 encoding.\n\n    Examples:\n        &gt;&gt;&gt; base32('MFZWIZLTOQ======')\n        True\n        &gt;&gt;&gt; base32('MfZW3zLT9Q======')\n        ValidationError(func=base32, args={'value': 'MfZW3zLT9Q======'})\n\n    Args:\n        value:\n            base32 string to validate.\n\n    Returns:\n        (Literal[True]): If `value` is a valid base32 encoding.\n        (ValidationError): If `value` is an invalid base32 encoding.\n    \"\"\"\n    return re.match(r\"^[A-Z2-7]+=*$\", value) if value else False\n</code></pre>"},{"location":"api/encoding/#validators.encoding.base58","title":"<code>validators.encoding.base58(value)</code>","text":"<p>Return whether or not given value is a valid base58 encoding.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; base58('14pq6y9H2DLGahPsM4s7ugsNSD2uxpHsJx')\nTrue\n&gt;&gt;&gt; base58('cUSECm5YzcXJwP')\nTrue\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>base58 string to validate.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid base58 encoding.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid base58 encoding.</p> Source code in <code>src/validators/encoding.py</code> <pre><code>@validator\ndef base58(value: str, /):\n    \"\"\"Return whether or not given value is a valid base58 encoding.\n\n    Examples:\n        &gt;&gt;&gt; base58('14pq6y9H2DLGahPsM4s7ugsNSD2uxpHsJx')\n        True\n        &gt;&gt;&gt; base58('cUSECm5YzcXJwP')\n        True\n\n    Args:\n        value:\n            base58 string to validate.\n\n    Returns:\n        (Literal[True]): If `value` is a valid base58 encoding.\n        (ValidationError): If `value` is an invalid base58 encoding.\n    \"\"\"\n    return re.match(r\"^[1-9A-HJ-NP-Za-km-z]+$\", value) if value else False\n</code></pre>"},{"location":"api/encoding/#validators.encoding.base64","title":"<code>validators.encoding.base64(value)</code>","text":"<p>Return whether or not given value is a valid base64 encoding.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; base64('Y2hhcmFjdGVyIHNldA==')\nTrue\n&gt;&gt;&gt; base64('cUSECm5YzcXJwP')\nValidationError(func=base64, args={'value': 'cUSECm5YzcXJwP'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>base64 string to validate.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid base64 encoding.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid base64 encoding.</p> Source code in <code>src/validators/encoding.py</code> <pre><code>@validator\ndef base64(value: str, /):\n    \"\"\"Return whether or not given value is a valid base64 encoding.\n\n    Examples:\n        &gt;&gt;&gt; base64('Y2hhcmFjdGVyIHNldA==')\n        True\n        &gt;&gt;&gt; base64('cUSECm5YzcXJwP')\n        ValidationError(func=base64, args={'value': 'cUSECm5YzcXJwP'})\n\n    Args:\n        value:\n            base64 string to validate.\n\n    Returns:\n        (Literal[True]): If `value` is a valid base64 encoding.\n        (ValidationError): If `value` is an invalid base64 encoding.\n    \"\"\"\n    return (\n        re.match(r\"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\", value)\n        if value\n        else False\n    )\n</code></pre>"},{"location":"api/finance/","title":"finance","text":""},{"location":"api/finance/#validators.finance.cusip","title":"<code>validators.finance.cusip(value)</code>","text":"<p>Return whether or not given value is a valid CUSIP.</p> <p>Checks if the value is a valid CUSIP.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cusip('037833DP2')\nTrue\n&gt;&gt;&gt; cusip('037833DP3')\nValidationError(func=cusip, args={'value': '037833DP3'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>CUSIP string to validate.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid CUSIP string.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid CUSIP string.</p> Source code in <code>src/validators/finance.py</code> <pre><code>@validator\ndef cusip(value: str):\n    \"\"\"Return whether or not given value is a valid CUSIP.\n\n    Checks if the value is a valid [CUSIP][1].\n    [1]: https://en.wikipedia.org/wiki/CUSIP\n\n    Examples:\n        &gt;&gt;&gt; cusip('037833DP2')\n        True\n        &gt;&gt;&gt; cusip('037833DP3')\n        ValidationError(func=cusip, args={'value': '037833DP3'})\n\n    Args:\n        value: CUSIP string to validate.\n\n    Returns:\n        (Literal[True]): If `value` is a valid CUSIP string.\n        (ValidationError): If `value` is an invalid CUSIP string.\n    \"\"\"\n    return len(value) == 9 and _cusip_checksum(value)\n</code></pre>"},{"location":"api/finance/#validators.finance.isin","title":"<code>validators.finance.isin(value)</code>","text":"<p>Return whether or not given value is a valid ISIN.</p> <p>Checks if the value is a valid ISIN.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; isin('037833DP2')\nValidationError(func=isin, args={'value': '037833DP2'})\n&gt;&gt;&gt; isin('037833DP3')\nValidationError(func=isin, args={'value': '037833DP3'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>ISIN string to validate.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid ISIN string.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid ISIN string.</p> Source code in <code>src/validators/finance.py</code> <pre><code>@validator\ndef isin(value: str):\n    \"\"\"Return whether or not given value is a valid ISIN.\n\n    Checks if the value is a valid [ISIN][1].\n    [1]: https://en.wikipedia.org/wiki/International_Securities_Identification_Number\n\n    Examples:\n        &gt;&gt;&gt; isin('037833DP2')\n        ValidationError(func=isin, args={'value': '037833DP2'})\n        &gt;&gt;&gt; isin('037833DP3')\n        ValidationError(func=isin, args={'value': '037833DP3'})\n\n    Args:\n        value: ISIN string to validate.\n\n    Returns:\n        (Literal[True]): If `value` is a valid ISIN string.\n        (ValidationError): If `value` is an invalid ISIN string.\n    \"\"\"\n    return len(value) == 12 and _isin_checksum(value)\n</code></pre>"},{"location":"api/finance/#validators.finance.sedol","title":"<code>validators.finance.sedol(value)</code>","text":"<p>Return whether or not given value is a valid SEDOL.</p> <p>Checks if the value is a valid SEDOL.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sedol('2936921')\nTrue\n&gt;&gt;&gt; sedol('29A6922')\nValidationError(func=sedol, args={'value': '29A6922'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>SEDOL string to validate.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid SEDOL string.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid SEDOL string.</p> Source code in <code>src/validators/finance.py</code> <pre><code>@validator\ndef sedol(value: str):\n    \"\"\"Return whether or not given value is a valid SEDOL.\n\n    Checks if the value is a valid [SEDOL][1].\n    [1]: https://en.wikipedia.org/wiki/SEDOL\n\n    Examples:\n        &gt;&gt;&gt; sedol('2936921')\n        True\n        &gt;&gt;&gt; sedol('29A6922')\n        ValidationError(func=sedol, args={'value': '29A6922'})\n\n    Args:\n        value: SEDOL string to validate.\n\n    Returns:\n        (Literal[True]): If `value` is a valid SEDOL string.\n        (ValidationError): If `value` is an invalid SEDOL string.\n    \"\"\"\n    if len(value) != 7:\n        return False\n\n    weights = [1, 3, 1, 7, 3, 9, 1]\n    check = 0\n    for idx in range(7):\n        c = value[idx]\n        if c in \"AEIOU\":\n            return False\n\n        val = None\n        if c &gt;= \"0\" and c &lt;= \"9\":\n            val = ord(c) - ord(\"0\")\n        elif c &gt;= \"A\" and c &lt;= \"Z\":\n            val = 10 + ord(c) - ord(\"A\")\n        else:\n            return False\n        check += val * weights[idx]\n\n    return (check % 10) == 0\n</code></pre>"},{"location":"api/hashes/","title":"hashes","text":""},{"location":"api/hashes/#validators.hashes.md5","title":"<code>validators.hashes.md5(value)</code>","text":"<p>Return whether or not given value is a valid MD5 hash.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; md5('d41d8cd98f00b204e9800998ecf8427e')\nTrue\n&gt;&gt;&gt; md5('900zz11')\nValidationError(func=md5, args={'value': '900zz11'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>MD5 string to validate.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid MD5 hash.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid MD5 hash.</p> Source code in <code>src/validators/hashes.py</code> <pre><code>@validator\ndef md5(value: str, /):\n    \"\"\"Return whether or not given value is a valid MD5 hash.\n\n    Examples:\n        &gt;&gt;&gt; md5('d41d8cd98f00b204e9800998ecf8427e')\n        True\n        &gt;&gt;&gt; md5('900zz11')\n        ValidationError(func=md5, args={'value': '900zz11'})\n\n    Args:\n        value:\n            MD5 string to validate.\n\n    Returns:\n        (Literal[True]): If `value` is a valid MD5 hash.\n        (ValidationError): If `value` is an invalid MD5 hash.\n    \"\"\"\n    return re.match(r\"^[0-9a-f]{32}$\", value, re.IGNORECASE) if value else False\n</code></pre>"},{"location":"api/hashes/#validators.hashes.sha1","title":"<code>validators.hashes.sha1(value)</code>","text":"<p>Return whether or not given value is a valid SHA1 hash.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sha1('da39a3ee5e6b4b0d3255bfef95601890afd80709')\nTrue\n&gt;&gt;&gt; sha1('900zz11')\nValidationError(func=sha1, args={'value': '900zz11'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>SHA1 string to validate.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid SHA1 hash.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid SHA1 hash.</p> Source code in <code>src/validators/hashes.py</code> <pre><code>@validator\ndef sha1(value: str, /):\n    \"\"\"Return whether or not given value is a valid SHA1 hash.\n\n    Examples:\n        &gt;&gt;&gt; sha1('da39a3ee5e6b4b0d3255bfef95601890afd80709')\n        True\n        &gt;&gt;&gt; sha1('900zz11')\n        ValidationError(func=sha1, args={'value': '900zz11'})\n\n    Args:\n        value:\n            SHA1 string to validate.\n\n    Returns:\n        (Literal[True]): If `value` is a valid SHA1 hash.\n        (ValidationError): If `value` is an invalid SHA1 hash.\n    \"\"\"\n    return re.match(r\"^[0-9a-f]{40}$\", value, re.IGNORECASE) if value else False\n</code></pre>"},{"location":"api/hashes/#validators.hashes.sha224","title":"<code>validators.hashes.sha224(value)</code>","text":"<p>Return whether or not given value is a valid SHA224 hash.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sha224('d14a028c2a3a2bc9476102bb288234c415a2b01f828ea62ac5b3e42f')\nTrue\n&gt;&gt;&gt; sha224('900zz11')\nValidationError(func=sha224, args={'value': '900zz11'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>SHA224 string to validate.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid SHA224 hash.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid SHA224 hash.</p> Source code in <code>src/validators/hashes.py</code> <pre><code>@validator\ndef sha224(value: str, /):\n    \"\"\"Return whether or not given value is a valid SHA224 hash.\n\n    Examples:\n        &gt;&gt;&gt; sha224('d14a028c2a3a2bc9476102bb288234c415a2b01f828ea62ac5b3e42f')\n        True\n        &gt;&gt;&gt; sha224('900zz11')\n        ValidationError(func=sha224, args={'value': '900zz11'})\n\n    Args:\n        value:\n            SHA224 string to validate.\n\n    Returns:\n        (Literal[True]): If `value` is a valid SHA224 hash.\n        (ValidationError): If `value` is an invalid SHA224 hash.\n    \"\"\"\n    return re.match(r\"^[0-9a-f]{56}$\", value, re.IGNORECASE) if value else False\n</code></pre>"},{"location":"api/hashes/#validators.hashes.sha256","title":"<code>validators.hashes.sha256(value)</code>","text":"<p>Return whether or not given value is a valid SHA256 hash.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sha256(\n...     'e3b0c44298fc1c149afbf4c8996fb924'\n...     '27ae41e4649b934ca495991b7852b855'\n... )\nTrue\n&gt;&gt;&gt; sha256('900zz11')\nValidationError(func=sha256, args={'value': '900zz11'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>SHA256 string to validate.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid SHA256 hash.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid SHA256 hash.</p> Source code in <code>src/validators/hashes.py</code> <pre><code>@validator\ndef sha256(value: str, /):\n    \"\"\"Return whether or not given value is a valid SHA256 hash.\n\n    Examples:\n        &gt;&gt;&gt; sha256(\n        ...     'e3b0c44298fc1c149afbf4c8996fb924'\n        ...     '27ae41e4649b934ca495991b7852b855'\n        ... )\n        True\n        &gt;&gt;&gt; sha256('900zz11')\n        ValidationError(func=sha256, args={'value': '900zz11'})\n\n    Args:\n        value:\n            SHA256 string to validate.\n\n    Returns:\n        (Literal[True]): If `value` is a valid SHA256 hash.\n        (ValidationError): If `value` is an invalid SHA256 hash.\n    \"\"\"\n    return re.match(r\"^[0-9a-f]{64}$\", value, re.IGNORECASE) if value else False\n</code></pre>"},{"location":"api/hashes/#validators.hashes.sha384","title":"<code>validators.hashes.sha384(value)</code>","text":"<p>Return whether or not given value is a valid SHA384 hash.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sha384(\n...     'cb00753f45a35e8bb5a03d699ac65007272c32ab0eded163'\n...     '1a8b605a43ff5bed8086072ba1e7cc2358baeca134c825a7'\n... )\nTrue\n&gt;&gt;&gt; sha384('900zz11')\nValidationError(func=sha384, args={'value': '900zz11'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>SHA384 string to validate.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid SHA384 hash.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid SHA384 hash.</p> Source code in <code>src/validators/hashes.py</code> <pre><code>@validator\ndef sha384(value: str, /):\n    \"\"\"Return whether or not given value is a valid SHA384 hash.\n\n    Examples:\n        &gt;&gt;&gt; sha384(\n        ...     'cb00753f45a35e8bb5a03d699ac65007272c32ab0eded163'\n        ...     '1a8b605a43ff5bed8086072ba1e7cc2358baeca134c825a7'\n        ... )\n        True\n        &gt;&gt;&gt; sha384('900zz11')\n        ValidationError(func=sha384, args={'value': '900zz11'})\n\n    Args:\n        value:\n            SHA384 string to validate.\n\n    Returns:\n        (Literal[True]): If `value` is a valid SHA384 hash.\n        (ValidationError): If `value` is an invalid SHA384 hash.\n    \"\"\"\n    return re.match(r\"^[0-9a-f]{96}$\", value, re.IGNORECASE) if value else False\n</code></pre>"},{"location":"api/hashes/#validators.hashes.sha512","title":"<code>validators.hashes.sha512(value)</code>","text":"<p>Return whether or not given value is a valid SHA512 hash.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sha512(\n...     'cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce'\n...     '9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af9'\n...     '27da3e'\n... )\nTrue\n&gt;&gt;&gt; sha512('900zz11')\nValidationError(func=sha512, args={'value': '900zz11'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>SHA512 string to validate.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid SHA512 hash.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid SHA512 hash.</p> Source code in <code>src/validators/hashes.py</code> <pre><code>@validator\ndef sha512(value: str, /):\n    \"\"\"Return whether or not given value is a valid SHA512 hash.\n\n    Examples:\n        &gt;&gt;&gt; sha512(\n        ...     'cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce'\n        ...     '9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af9'\n        ...     '27da3e'\n        ... )\n        True\n        &gt;&gt;&gt; sha512('900zz11')\n        ValidationError(func=sha512, args={'value': '900zz11'})\n\n    Args:\n        value:\n            SHA512 string to validate.\n\n    Returns:\n        (Literal[True]): If `value` is a valid SHA512 hash.\n        (ValidationError): If `value` is an invalid SHA512 hash.\n    \"\"\"\n    return re.match(r\"^[0-9a-f]{128}$\", value, re.IGNORECASE) if value else False\n</code></pre>"},{"location":"api/hostname/","title":"hostname","text":""},{"location":"api/hostname/#validators.hostname.hostname","title":"<code>validators.hostname.hostname(value, /, *, skip_ipv6_addr=False, skip_ipv4_addr=False, may_have_port=True, maybe_simple=True, consider_tld=False, private=None, rfc_1034=False, rfc_2782=False)</code>","text":"<p>Return whether or not given value is a valid hostname.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; hostname(\"ubuntu-pc:443\")\nTrue\n&gt;&gt;&gt; hostname(\"this-pc\")\nTrue\n&gt;&gt;&gt; hostname(\"xn----gtbspbbmkef.xn--p1ai:65535\")\nTrue\n&gt;&gt;&gt; hostname(\"_example.com\")\nValidationError(func=hostname, args={'value': '_example.com'})\n&gt;&gt;&gt; hostname(\"123.5.77.88:31000\")\nTrue\n&gt;&gt;&gt; hostname(\"12.12.12.12\")\nTrue\n&gt;&gt;&gt; hostname(\"[::1]:22\")\nTrue\n&gt;&gt;&gt; hostname(\"dead:beef:0:0:0:0000:42:1\")\nTrue\n&gt;&gt;&gt; hostname(\"[0:0:0:0:0:ffff:1.2.3.4]:-65538\")\nValidationError(func=hostname, args={'value': '[0:0:0:0:0:ffff:1.2.3.4]:-65538'})\n&gt;&gt;&gt; hostname(\"[0:&amp;:b:c:@:e:f::]:9999\")\nValidationError(func=hostname, args={'value': '[0:&amp;:b:c:@:e:f::]:9999'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Hostname string to validate.</p> required <code>skip_ipv6_addr</code> <code>bool</code> <p>When hostname string cannot be an IPv6 address.</p> <code>False</code> <code>skip_ipv4_addr</code> <code>bool</code> <p>When hostname string cannot be an IPv4 address.</p> <code>False</code> <code>may_have_port</code> <code>bool</code> <p>Hostname string may contain port number.</p> <code>True</code> <code>maybe_simple</code> <code>bool</code> <p>Hostname string maybe only hyphens and alpha-numerals.</p> <code>True</code> <code>consider_tld</code> <code>bool</code> <p>Restrict domain to TLDs allowed by IANA.</p> <code>False</code> <code>private</code> <code>Optional[bool]</code> <p>Embedded IP address is public if <code>False</code>, private/local if <code>True</code>.</p> <code>None</code> <code>rfc_1034</code> <code>bool</code> <p>Allow trailing dot in domain/host name. Ref: RFC 1034.</p> <code>False</code> <code>rfc_2782</code> <code>bool</code> <p>Domain/Host name is of type service record. Ref: RFC 2782.</p> <code>False</code> <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid hostname.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid hostname.</p> Source code in <code>src/validators/hostname.py</code> <pre><code>@validator\ndef hostname(\n    value: str,\n    /,\n    *,\n    skip_ipv6_addr: bool = False,\n    skip_ipv4_addr: bool = False,\n    may_have_port: bool = True,\n    maybe_simple: bool = True,\n    consider_tld: bool = False,\n    private: Optional[bool] = None,  # only for ip-addresses\n    rfc_1034: bool = False,\n    rfc_2782: bool = False,\n):\n    \"\"\"Return whether or not given value is a valid hostname.\n\n    Examples:\n        &gt;&gt;&gt; hostname(\"ubuntu-pc:443\")\n        True\n        &gt;&gt;&gt; hostname(\"this-pc\")\n        True\n        &gt;&gt;&gt; hostname(\"xn----gtbspbbmkef.xn--p1ai:65535\")\n        True\n        &gt;&gt;&gt; hostname(\"_example.com\")\n        ValidationError(func=hostname, args={'value': '_example.com'})\n        &gt;&gt;&gt; hostname(\"123.5.77.88:31000\")\n        True\n        &gt;&gt;&gt; hostname(\"12.12.12.12\")\n        True\n        &gt;&gt;&gt; hostname(\"[::1]:22\")\n        True\n        &gt;&gt;&gt; hostname(\"dead:beef:0:0:0:0000:42:1\")\n        True\n        &gt;&gt;&gt; hostname(\"[0:0:0:0:0:ffff:1.2.3.4]:-65538\")\n        ValidationError(func=hostname, args={'value': '[0:0:0:0:0:ffff:1.2.3.4]:-65538'})\n        &gt;&gt;&gt; hostname(\"[0:&amp;:b:c:@:e:f::]:9999\")\n        ValidationError(func=hostname, args={'value': '[0:&amp;:b:c:@:e:f::]:9999'})\n\n    Args:\n        value:\n            Hostname string to validate.\n        skip_ipv6_addr:\n            When hostname string cannot be an IPv6 address.\n        skip_ipv4_addr:\n            When hostname string cannot be an IPv4 address.\n        may_have_port:\n            Hostname string may contain port number.\n        maybe_simple:\n            Hostname string maybe only hyphens and alpha-numerals.\n        consider_tld:\n            Restrict domain to TLDs allowed by IANA.\n        private:\n            Embedded IP address is public if `False`, private/local if `True`.\n        rfc_1034:\n            Allow trailing dot in domain/host name.\n            Ref: [RFC 1034](https://www.rfc-editor.org/rfc/rfc1034).\n        rfc_2782:\n            Domain/Host name is of type service record.\n            Ref: [RFC 2782](https://www.rfc-editor.org/rfc/rfc2782).\n\n    Returns:\n        (Literal[True]): If `value` is a valid hostname.\n        (ValidationError): If `value` is an invalid hostname.\n    \"\"\"\n    if not value:\n        return False\n\n    if may_have_port and (host_seg := _port_validator(value)):\n        return (\n            (_simple_hostname_regex().match(host_seg) if maybe_simple else False)\n            or domain(host_seg, consider_tld=consider_tld, rfc_1034=rfc_1034, rfc_2782=rfc_2782)\n            or (False if skip_ipv4_addr else ipv4(host_seg, cidr=False, private=private))\n            or (False if skip_ipv6_addr else ipv6(host_seg, cidr=False))\n        )\n\n    return (\n        (_simple_hostname_regex().match(value) if maybe_simple else False)\n        or domain(value, consider_tld=consider_tld, rfc_1034=rfc_1034, rfc_2782=rfc_2782)\n        or (False if skip_ipv4_addr else ipv4(value, cidr=False, private=private))\n        or (False if skip_ipv6_addr else ipv6(value, cidr=False))\n    )\n</code></pre>"},{"location":"api/i18n/","title":"i18n","text":""},{"location":"api/i18n/#validators.i18n.es_cif","title":"<code>validators.i18n.es_cif(value)</code>","text":"<p>Validate a Spanish CIF.</p> <p>Each company in Spain prior to 2008 had a distinct CIF and has been discontinued. For more information see wikipedia.org/cif.</p> <p>The new replacement is to use NIF for absolutely everything. The issue is that there are \"types\" of NIFs now: company, person [citizen or resident] all distinguished by the first character of the DOI. For this reason we will continue to call CIFs NIFs, that are used for companies.</p> <p>This validator is based on generadordni.es.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; es_cif('B25162520')\nTrue\n&gt;&gt;&gt; es_cif('B25162529')\nValidationError(func=es_cif, args={'value': 'B25162529'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>DOI string which is to be validated.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid DOI string.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid DOI string.</p> Source code in <code>src/validators/i18n/es.py</code> <pre><code>@validator\ndef es_cif(value: str, /):\n    \"\"\"Validate a Spanish CIF.\n\n    Each company in Spain prior to 2008 had a distinct CIF and has been\n    discontinued. For more information see [wikipedia.org/cif][1].\n\n    The new replacement is to use NIF for absolutely everything. The issue is\n    that there are \"types\" of NIFs now: company, person [citizen or resident]\n    all distinguished by the first character of the DOI. For this reason we\n    will continue to call CIFs NIFs, that are used for companies.\n\n    This validator is based on [generadordni.es][2].\n\n    [1]: https://es.wikipedia.org/wiki/C%C3%B3digo_de_identificaci%C3%B3n_fiscal\n    [2]: https://generadordni.es/\n\n    Examples:\n        &gt;&gt;&gt; es_cif('B25162520')\n        True\n        &gt;&gt;&gt; es_cif('B25162529')\n        ValidationError(func=es_cif, args={'value': 'B25162529'})\n\n    Args:\n        value:\n            DOI string which is to be validated.\n\n    Returns:\n        (Literal[True]): If `value` is a valid DOI string.\n        (ValidationError): If `value` is an invalid DOI string.\n    \"\"\"\n    if not value or len(value) != 9:\n        return False\n    value = value.upper()\n    table = \"JABCDEFGHI\"\n    first_chr = value[0]\n    doi_body = value[1:8]\n    control = value[8]\n    if not doi_body.isdigit():\n        return False\n    res = (\n        10\n        - sum(\n            # Multiply each positionally even doi\n            # digit by 2 and sum it all together\n            sum(map(int, str(int(char) * 2))) if index % 2 == 0 else int(char)\n            for index, char in enumerate(doi_body)\n        )\n        % 10\n    ) % 10\n    if first_chr in \"ABEH\":  # Number type\n        return str(res) == control\n    if first_chr in \"PSQW\":  # Letter type\n        return table[res] == control\n    return control in {str(res), table[res]} if first_chr in \"CDFGJNRUV\" else False\n</code></pre>"},{"location":"api/i18n/#validators.i18n.es_doi","title":"<code>validators.i18n.es_doi(value)</code>","text":"<p>Validate a Spanish DOI.</p> <p>A DOI in spain is all NIF / CIF / NIE / DNI -- a digital ID. For more information see wikipedia.org/doi. This validator is based on generadordni.es.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; es_doi('X0095892M')\nTrue\n&gt;&gt;&gt; es_doi('X0095892X')\nValidationError(func=es_doi, args={'value': 'X0095892X'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>DOI string which is to be validated.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid DOI string.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid DOI string.</p> Source code in <code>src/validators/i18n/es.py</code> <pre><code>@validator\ndef es_doi(value: str, /):\n    \"\"\"Validate a Spanish DOI.\n\n    A DOI in spain is all NIF / CIF / NIE / DNI -- a digital ID.\n    For more information see [wikipedia.org/doi][1]. This validator\n    is based on [generadordni.es][2].\n\n    [1]: https://es.wikipedia.org/wiki/Identificador_de_objeto_digital\n    [2]: https://generadordni.es/\n\n    Examples:\n        &gt;&gt;&gt; es_doi('X0095892M')\n        True\n        &gt;&gt;&gt; es_doi('X0095892X')\n        ValidationError(func=es_doi, args={'value': 'X0095892X'})\n\n    Args:\n        value:\n            DOI string which is to be validated.\n\n    Returns:\n        (Literal[True]): If `value` is a valid DOI string.\n        (ValidationError): If `value` is an invalid DOI string.\n    \"\"\"\n    return es_nie(value) or es_nif(value) or es_cif(value)\n</code></pre>"},{"location":"api/i18n/#validators.i18n.es_nie","title":"<code>validators.i18n.es_nie(value)</code>","text":"<p>Validate a Spanish NIE.</p> <p>The NIE is a tax identification number in Spain, known in Spanish as the NIE, or more formally the N\u00famero de identidad de extranjero. For more information see wikipedia.org/nie. This validator is based on generadordni.es.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; es_nie('X0095892M')\nTrue\n&gt;&gt;&gt; es_nie('X0095892X')\nValidationError(func=es_nie, args={'value': 'X0095892X'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>DOI string which is to be validated.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid DOI string.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid DOI string.</p> Source code in <code>src/validators/i18n/es.py</code> <pre><code>@validator\ndef es_nie(value: str, /):\n    \"\"\"Validate a Spanish NIE.\n\n    The NIE is a tax identification number in Spain, known in Spanish\n    as the NIE, or more formally the N\u00famero de identidad de extranjero.\n    For more information see [wikipedia.org/nie][1]. This validator\n    is based on [generadordni.es][2].\n\n    [1]: https://es.wikipedia.org/wiki/N%C3%BAmero_de_identidad_de_extranjero\n    [2]: https://generadordni.es/\n\n    Examples:\n        &gt;&gt;&gt; es_nie('X0095892M')\n        True\n        &gt;&gt;&gt; es_nie('X0095892X')\n        ValidationError(func=es_nie, args={'value': 'X0095892X'})\n\n    Args:\n        value:\n            DOI string which is to be validated.\n\n    Returns:\n        (Literal[True]): If `value` is a valid DOI string.\n        (ValidationError): If `value` is an invalid DOI string.\n    \"\"\"\n    number_by_letter = {\"X\": \"0\", \"Y\": \"1\", \"Z\": \"2\"}\n    # NIE must must start with X Y or Z\n    if value and value[0] in number_by_letter:\n        return _nif_nie_validation(value, number_by_letter)\n    return False\n</code></pre>"},{"location":"api/i18n/#validators.i18n.es_nif","title":"<code>validators.i18n.es_nif(value)</code>","text":"<p>Validate a Spanish NIF.</p> <p>Each entity, be it person or company in Spain has a distinct NIF. Since we've designated CIF to be a company NIF, this NIF is only for person. For more information see wikipedia.org/nif. This validator is based on generadordni.es.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; es_nif('26643189N')\nTrue\n&gt;&gt;&gt; es_nif('26643189X')\nValidationError(func=es_nif, args={'value': '26643189X'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>DOI string which is to be validated.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid DOI string.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid DOI string.</p> Source code in <code>src/validators/i18n/es.py</code> <pre><code>@validator\ndef es_nif(value: str, /):\n    \"\"\"Validate a Spanish NIF.\n\n    Each entity, be it person or company in Spain has a distinct NIF. Since\n    we've designated CIF to be a company NIF, this NIF is only for person.\n    For more information see [wikipedia.org/nif][1]. This validator\n    is based on [generadordni.es][2].\n\n    [1]: https://es.wikipedia.org/wiki/N%C3%BAmero_de_identificaci%C3%B3n_fiscal\n    [2]: https://generadordni.es/\n\n    Examples:\n        &gt;&gt;&gt; es_nif('26643189N')\n        True\n        &gt;&gt;&gt; es_nif('26643189X')\n        ValidationError(func=es_nif, args={'value': '26643189X'})\n\n    Args:\n        value:\n            DOI string which is to be validated.\n\n    Returns:\n        (Literal[True]): If `value` is a valid DOI string.\n        (ValidationError): If `value` is an invalid DOI string.\n    \"\"\"\n    number_by_letter = {\"L\": \"0\", \"M\": \"0\", \"K\": \"0\"}\n    return _nif_nie_validation(value, number_by_letter)\n</code></pre>"},{"location":"api/i18n/#validators.i18n.fi_business_id","title":"<code>validators.i18n.fi_business_id(value)</code>","text":"<p>Validate a Finnish Business ID.</p> <p>Each company in Finland has a distinct business id. For more information see Finnish Trade Register</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fi_business_id('0112038-9')  # Fast Monkeys Ltd\nTrue\n&gt;&gt;&gt; fi_business_id('1234567-8')  # Bogus ID\nValidationError(func=fi_business_id, args={'value': '1234567-8'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Business ID string to be validated.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid finnish business id.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid finnish business id.</p> Source code in <code>src/validators/i18n/fi.py</code> <pre><code>@validator\ndef fi_business_id(value: str, /):\n    \"\"\"Validate a Finnish Business ID.\n\n    Each company in Finland has a distinct business id. For more\n    information see [Finnish Trade Register][1]\n\n    [1]: http://en.wikipedia.org/wiki/Finnish_Trade_Register\n\n    Examples:\n        &gt;&gt;&gt; fi_business_id('0112038-9')  # Fast Monkeys Ltd\n        True\n        &gt;&gt;&gt; fi_business_id('1234567-8')  # Bogus ID\n        ValidationError(func=fi_business_id, args={'value': '1234567-8'})\n\n    Args:\n        value:\n            Business ID string to be validated.\n\n    Returns:\n        (Literal[True]): If `value` is a valid finnish business id.\n        (ValidationError): If `value` is an invalid finnish business id.\n    \"\"\"\n    if not value:\n        return False\n    if not re.match(_business_id_pattern(), value):\n        return False\n    factors = [7, 9, 10, 5, 8, 4, 2]\n    numbers = map(int, value[:7])\n    checksum = int(value[8])\n    modulo = sum(f * n for f, n in zip(factors, numbers)) % 11\n    return (11 - modulo == checksum) or (modulo == checksum == 0)\n</code></pre>"},{"location":"api/i18n/#validators.i18n.fi_ssn","title":"<code>validators.i18n.fi_ssn(value, /, *, allow_temporal_ssn=True)</code>","text":"<p>Validate a Finnish Social Security Number.</p> <p>This validator is based on django-localflavor-fi.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fi_ssn('010101-0101')\nTrue\n&gt;&gt;&gt; fi_ssn('101010-0102')\nValidationError(func=fi_ssn, args={'value': '101010-0102'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Social Security Number to be validated.</p> required <code>allow_temporal_ssn</code> <code>bool</code> <p>Whether to accept temporal SSN numbers. Temporal SSN numbers are the ones where the serial is in the range [900-999]. By default temporal SSN numbers are valid.</p> <code>True</code> <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid finnish SSN.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid finnish SSN.</p> Source code in <code>src/validators/i18n/fi.py</code> <pre><code>@validator\ndef fi_ssn(value: str, /, *, allow_temporal_ssn: bool = True):\n    \"\"\"Validate a Finnish Social Security Number.\n\n    This validator is based on [django-localflavor-fi][1].\n\n    [1]: https://github.com/django/django-localflavor-fi/\n\n    Examples:\n        &gt;&gt;&gt; fi_ssn('010101-0101')\n        True\n        &gt;&gt;&gt; fi_ssn('101010-0102')\n        ValidationError(func=fi_ssn, args={'value': '101010-0102'})\n\n    Args:\n        value:\n            Social Security Number to be validated.\n        allow_temporal_ssn:\n            Whether to accept temporal SSN numbers. Temporal SSN numbers are the\n            ones where the serial is in the range [900-999]. By default temporal\n            SSN numbers are valid.\n\n    Returns:\n        (Literal[True]): If `value` is a valid finnish SSN.\n        (ValidationError): If `value` is an invalid finnish SSN.\n    \"\"\"\n    if not value:\n        return False\n    ssn_check_marks = \"0123456789ABCDEFHJKLMNPRSTUVWXY\"\n    if not (result := re.match(_ssn_pattern(ssn_check_marks), value)):\n        return False\n    gd = result.groupdict()\n    checksum = int(gd[\"date\"] + gd[\"serial\"])\n    return (\n        int(gd[\"serial\"]) &gt;= 2\n        and (allow_temporal_ssn or int(gd[\"serial\"]) &lt;= 899)\n        and ssn_check_marks[checksum % len(ssn_check_marks)] == gd[\"checksum\"]\n    )\n</code></pre>"},{"location":"api/i18n/#validators.i18n.fr_department","title":"<code>validators.i18n.fr_department(value)</code>","text":"<p>Validate a french department number.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fr_department(20)  # can be an integer\nValidationError(func=fr_department, args={'value': 20})\n&gt;&gt;&gt; fr_department(\"20\")\nValidationError(func=fr_department, args={'value': '20'})\n&gt;&gt;&gt; fr_department(\"971\")  # Guadeloupe\nTrue\n&gt;&gt;&gt; fr_department(\"00\")\nValidationError(func=fr_department, args={'value': '00'})\n&gt;&gt;&gt; fr_department('2A')  # Corsica\nTrue\n&gt;&gt;&gt; fr_department('2B')\nTrue\n&gt;&gt;&gt; fr_department('2C')\nValidationError(func=fr_department, args={'value': '2C'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Union[str, int]</code> <p>French department number to validate.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid french department number.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid french department number.</p> Source code in <code>src/validators/i18n/fr.py</code> <pre><code>@validator\ndef fr_department(value: typing.Union[str, int]):\n    \"\"\"Validate a french department number.\n\n    Examples:\n        &gt;&gt;&gt; fr_department(20)  # can be an integer\n        ValidationError(func=fr_department, args={'value': 20})\n        &gt;&gt;&gt; fr_department(\"20\")\n        ValidationError(func=fr_department, args={'value': '20'})\n        &gt;&gt;&gt; fr_department(\"971\")  # Guadeloupe\n        True\n        &gt;&gt;&gt; fr_department(\"00\")\n        ValidationError(func=fr_department, args={'value': '00'})\n        &gt;&gt;&gt; fr_department('2A')  # Corsica\n        True\n        &gt;&gt;&gt; fr_department('2B')\n        True\n        &gt;&gt;&gt; fr_department('2C')\n        ValidationError(func=fr_department, args={'value': '2C'})\n\n    Args:\n        value:\n            French department number to validate.\n\n    Returns:\n        (Literal[True]): If `value` is a valid french department number.\n        (ValidationError): If `value` is an invalid french department number.\n    \"\"\"\n    if not value:\n        return False\n    if isinstance(value, str):\n        if value in (\"2A\", \"2B\"):  # Corsica\n            return True\n        try:\n            value = int(value)\n        except ValueError:\n            return False\n    return 1 &lt;= value &lt;= 19 or 21 &lt;= value &lt;= 95 or 971 &lt;= value &lt;= 976  # Overseas departments\n</code></pre>"},{"location":"api/i18n/#validators.i18n.fr_ssn","title":"<code>validators.i18n.fr_ssn(value)</code>","text":"<p>Validate a french Social Security Number.</p> <p>Each french citizen has a distinct Social Security Number. For more information see French Social Security Number (sadly unavailable in english).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fr_ssn('1 84 12 76 451 089 46')\nTrue\n&gt;&gt;&gt; fr_ssn('1 84 12 76 451 089')  # control key is optional\nTrue\n&gt;&gt;&gt; fr_ssn('3 84 12 76 451 089 46')  # wrong gender number\nValidationError(func=fr_ssn, args={'value': '3 84 12 76 451 089 46'})\n&gt;&gt;&gt; fr_ssn('1 84 12 76 451 089 47')  # wrong control key\nValidationError(func=fr_ssn, args={'value': '1 84 12 76 451 089 47'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>French Social Security Number string to validate.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid french Social Security Number.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid french Social Security Number.</p> Source code in <code>src/validators/i18n/fr.py</code> <pre><code>@validator\ndef fr_ssn(value: str):\n    \"\"\"Validate a french Social Security Number.\n\n    Each french citizen has a distinct Social Security Number.\n    For more information see [French Social Security Number][1] (sadly unavailable in english).\n\n    [1]: https://fr.wikipedia.org/wiki/Num%C3%A9ro_de_s%C3%A9curit%C3%A9_sociale_en_France\n\n    Examples:\n        &gt;&gt;&gt; fr_ssn('1 84 12 76 451 089 46')\n        True\n        &gt;&gt;&gt; fr_ssn('1 84 12 76 451 089')  # control key is optional\n        True\n        &gt;&gt;&gt; fr_ssn('3 84 12 76 451 089 46')  # wrong gender number\n        ValidationError(func=fr_ssn, args={'value': '3 84 12 76 451 089 46'})\n        &gt;&gt;&gt; fr_ssn('1 84 12 76 451 089 47')  # wrong control key\n        ValidationError(func=fr_ssn, args={'value': '1 84 12 76 451 089 47'})\n\n    Args:\n        value:\n            French Social Security Number string to validate.\n\n    Returns:\n        (Literal[True]): If `value` is a valid french Social Security Number.\n        (ValidationError): If `value` is an invalid french Social Security Number.\n    \"\"\"\n    if not value:\n        return False\n    matched = re.match(_ssn_pattern(), value)\n    if not matched:\n        return False\n    groups = list(matched.groups())\n    control_key = groups[-1]\n    department = groups[3]\n    if department != \"99\" and not fr_department(department):\n        # 99 stands for foreign born people\n        return False\n    if control_key is None:\n        # no control key provided, no additional check needed\n        return True\n    if len(department) == len(groups[4]):\n        # if the department number is 3 digits long (overseas departments),\n        # the town number must be 2 digits long\n        # and vice versa\n        return False\n    if department in (\"2A\", \"2B\"):\n        # Corsica's department numbers are not in the same range as the others\n        # thus 2A and 2B are replaced by 19 and 18 respectively to compute the control key\n        groups[3] = \"19\" if department == \"2A\" else \"18\"\n    # the control key is valid if it is equal to 97 - (the first 13 digits modulo 97)\n    digits = int(\"\".join(groups[:-1]))\n    return int(control_key) == (97 - (digits % 97))\n</code></pre>"},{"location":"api/i18n/#validators.i18n.ind_aadhar","title":"<code>validators.i18n.ind_aadhar(value)</code>","text":"<p>Validate an indian aadhar card number.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ind_aadhar('3675 9834 6015')\nTrue\n&gt;&gt;&gt; ind_aadhar('3675 ABVC 2133')\nValidationError(func=ind_aadhar, args={'value': '3675 ABVC 2133'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Aadhar card number string to validate.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid aadhar card number.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid aadhar card number.</p> Source code in <code>src/validators/i18n/ind.py</code> <pre><code>@validator\ndef ind_aadhar(value: str):\n    \"\"\"Validate an indian aadhar card number.\n\n    Examples:\n        &gt;&gt;&gt; ind_aadhar('3675 9834 6015')\n        True\n        &gt;&gt;&gt; ind_aadhar('3675 ABVC 2133')\n        ValidationError(func=ind_aadhar, args={'value': '3675 ABVC 2133'})\n\n    Args:\n        value: Aadhar card number string to validate.\n\n    Returns:\n        (Literal[True]): If `value` is a valid aadhar card number.\n        (ValidationError): If `value` is an invalid aadhar card number.\n    \"\"\"\n    return re.match(r\"^[2-9]{1}\\d{3}\\s\\d{4}\\s\\d{4}$\", value)\n</code></pre>"},{"location":"api/i18n/#validators.i18n.ind_pan","title":"<code>validators.i18n.ind_pan(value)</code>","text":"<p>Validate a pan card number.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ind_pan('ABCDE9999K')\nTrue\n&gt;&gt;&gt; ind_pan('ABC5d7896B')\nValidationError(func=ind_pan, args={'value': 'ABC5d7896B'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>PAN card number string to validate.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid PAN card number.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid PAN card number.</p> Source code in <code>src/validators/i18n/ind.py</code> <pre><code>@validator\ndef ind_pan(value: str):\n    \"\"\"Validate a pan card number.\n\n    Examples:\n        &gt;&gt;&gt; ind_pan('ABCDE9999K')\n        True\n        &gt;&gt;&gt; ind_pan('ABC5d7896B')\n        ValidationError(func=ind_pan, args={'value': 'ABC5d7896B'})\n\n    Args:\n        value: PAN card number string to validate.\n\n    Returns:\n        (Literal[True]): If `value` is a valid PAN card number.\n        (ValidationError): If `value` is an invalid PAN card number.\n    \"\"\"\n    return re.match(r\"[A-Z]{5}\\d{4}[A-Z]{1}\", value)\n</code></pre>"},{"location":"api/i18n/#validators.i18n.ru_inn","title":"<code>validators.i18n.ru_inn(value)</code>","text":"<p>Validate a Russian INN (Taxpayer Identification Number).</p> <p>The INN can be either 10 digits (for companies) or 12 digits (for individuals). The function checks both the length and the control digits according to Russian tax rules.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ru_inn('500100732259')  # Valid 12-digit INN\nTrue\n&gt;&gt;&gt; ru_inn('7830002293')    # Valid 10-digit INN\nTrue\n&gt;&gt;&gt; ru_inn('1234567890')    # Invalid INN\nValidationError(func=ru_inn, args={'value': '1234567890'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Russian INN string to validate. Can contain only digits.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid Russian INN.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid Russian INN.</p> Note <p>The validation follows the official algorithm: - For 10-digit INN: checks 10th control digit - For 12-digit INN: checks both 11th and 12th control digits</p> Source code in <code>src/validators/i18n/ru.py</code> <pre><code>@validator\ndef ru_inn(value: str):\n    \"\"\"Validate a Russian INN (Taxpayer Identification Number).\n\n    The INN can be either 10 digits (for companies) or 12 digits (for individuals).\n    The function checks both the length and the control digits according to Russian tax rules.\n\n    Examples:\n        &gt;&gt;&gt; ru_inn('500100732259')  # Valid 12-digit INN\n        True\n        &gt;&gt;&gt; ru_inn('7830002293')    # Valid 10-digit INN\n        True\n        &gt;&gt;&gt; ru_inn('1234567890')    # Invalid INN\n        ValidationError(func=ru_inn, args={'value': '1234567890'})\n\n    Args:\n        value: Russian INN string to validate. Can contain only digits.\n\n    Returns:\n        (Literal[True]): If `value` is a valid Russian INN.\n        (ValidationError): If `value` is an invalid Russian INN.\n\n    Note:\n        The validation follows the official algorithm:\n        - For 10-digit INN: checks 10th control digit\n        - For 12-digit INN: checks both 11th and 12th control digits\n    \"\"\"\n    if not value:\n        return False\n\n    try:\n        digits = list(map(int, value))\n        # company\n        if len(digits) == 10:\n            weight_coefs = [2, 4, 10, 3, 5, 9, 4, 6, 8, 0]\n            control_number = sum([d * w for d, w in zip(digits, weight_coefs)]) % 11\n            return (\n                (control_number % 10) == digits[-1]\n                if control_number &gt; 9\n                else control_number == digits[-1]\n            )\n        # person\n        elif len(digits) == 12:\n            weight_coefs1 = [7, 2, 4, 10, 3, 5, 9, 4, 6, 8, 0, 0]\n            control_number1 = sum([d * w for d, w in zip(digits, weight_coefs1)]) % 11\n            weight_coefs2 = [3, 7, 2, 4, 10, 3, 5, 9, 4, 6, 8, 0]\n            control_number2 = sum([d * w for d, w in zip(digits, weight_coefs2)]) % 11\n            return (\n                (control_number1 % 10) == digits[-2]\n                if control_number1 &gt; 9\n                else control_number1 == digits[-2] and (control_number2 % 10) == digits[-1]\n                if control_number2 &gt; 9\n                else control_number2 == digits[-1]\n            )\n        else:\n            return False\n    except ValueError:\n        return False\n</code></pre>"},{"location":"api/iban/","title":"iban","text":""},{"location":"api/iban/#validators.iban.iban","title":"<code>validators.iban.iban(value)</code>","text":"<p>Return whether or not given value is a valid IBAN code.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; iban('DE29100500001061045672')\nTrue\n&gt;&gt;&gt; iban('123456')\nValidationError(func=iban, args={'value': '123456'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>IBAN string to validate.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid IBAN code.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid IBAN code.</p> Source code in <code>src/validators/iban.py</code> <pre><code>@validator\ndef iban(value: str, /):\n    \"\"\"Return whether or not given value is a valid IBAN code.\n\n    Examples:\n        &gt;&gt;&gt; iban('DE29100500001061045672')\n        True\n        &gt;&gt;&gt; iban('123456')\n        ValidationError(func=iban, args={'value': '123456'})\n\n    Args:\n        value:\n            IBAN string to validate.\n\n    Returns:\n        (Literal[True]): If `value` is a valid IBAN code.\n        (ValidationError): If `value` is an invalid IBAN code.\n    \"\"\"\n    return (\n        (re.match(r\"^[a-z]{2}[0-9]{2}[a-z0-9]{11,30}$\", value, re.IGNORECASE) and _mod_check(value))\n        if value\n        else False\n    )\n</code></pre>"},{"location":"api/ip_address/","title":"ip_address","text":""},{"location":"api/ip_address/#validators.ip_address.ipv4","title":"<code>validators.ip_address.ipv4(value, /, *, cidr=True, strict=False, private=None, host_bit=True)</code>","text":"<p>Returns whether a given value is a valid IPv4 address.</p> <p>From Python version 3.9.5 leading zeros are no longer tolerated and are treated as an error. The initial version of ipv4 validator was inspired from WTForms IPAddress validator.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ipv4('123.0.0.7')\nTrue\n&gt;&gt;&gt; ipv4('1.1.1.1/8')\nTrue\n&gt;&gt;&gt; ipv4('900.80.70.11')\nValidationError(func=ipv4, args={'value': '900.80.70.11'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>IP address string to validate.</p> required <code>cidr</code> <code>bool</code> <p>IP address string may contain CIDR notation.</p> <code>True</code> <code>strict</code> <code>bool</code> <p>IP address string is strictly in CIDR notation.</p> <code>False</code> <code>private</code> <code>Optional[bool]</code> <p>IP address is public if <code>False</code>, private/local/loopback/broadcast if <code>True</code>.</p> <code>None</code> <code>host_bit</code> <code>bool</code> <p>If <code>False</code> and host bits (along with network bits) are set in the supplied address, this function raises a validation error. ref IPv4Network.</p> <code>True</code> <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid IPv4 address.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid IPv4 address.</p> Source code in <code>src/validators/ip_address.py</code> <pre><code>@validator\ndef ipv4(\n    value: str,\n    /,\n    *,\n    cidr: bool = True,\n    strict: bool = False,\n    private: Optional[bool] = None,\n    host_bit: bool = True,\n):\n    \"\"\"Returns whether a given value is a valid IPv4 address.\n\n    From Python version 3.9.5 leading zeros are no longer tolerated\n    and are treated as an error. The initial version of ipv4 validator\n    was inspired from [WTForms IPAddress validator][1].\n\n    [1]: https://github.com/wtforms/wtforms/blob/master/src/wtforms/validators.py\n\n    Examples:\n        &gt;&gt;&gt; ipv4('123.0.0.7')\n        True\n        &gt;&gt;&gt; ipv4('1.1.1.1/8')\n        True\n        &gt;&gt;&gt; ipv4('900.80.70.11')\n        ValidationError(func=ipv4, args={'value': '900.80.70.11'})\n\n    Args:\n        value:\n            IP address string to validate.\n        cidr:\n            IP address string may contain CIDR notation.\n        strict:\n            IP address string is strictly in CIDR notation.\n        private:\n            IP address is public if `False`, private/local/loopback/broadcast if `True`.\n        host_bit:\n            If `False` and host bits (along with network bits) _are_ set in the supplied\n            address, this function raises a validation error. ref [IPv4Network][2].\n            [2]: https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv4Network\n\n    Returns:\n        (Literal[True]): If `value` is a valid IPv4 address.\n        (ValidationError): If `value` is an invalid IPv4 address.\n    \"\"\"\n    if not value:\n        return False\n    try:\n        if cidr:\n            if strict and value.count(\"/\") != 1:\n                raise ValueError(\"IPv4 address was expected in CIDR notation\")\n            return IPv4Network(value, strict=not host_bit) and _check_private_ip(value, private)\n        return IPv4Address(value) and _check_private_ip(value, private)\n    except (ValueError, AddressValueError, NetmaskValueError):\n        return False\n</code></pre>"},{"location":"api/ip_address/#validators.ip_address.ipv6","title":"<code>validators.ip_address.ipv6(value, /, *, cidr=True, strict=False, host_bit=True)</code>","text":"<p>Returns if a given value is a valid IPv6 address.</p> <p>Including IPv4-mapped IPv6 addresses. The initial version of ipv6 validator was inspired from WTForms IPAddress validator.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ipv6('::ffff:192.0.2.128')\nTrue\n&gt;&gt;&gt; ipv6('::1/128')\nTrue\n&gt;&gt;&gt; ipv6('abc.0.0.1')\nValidationError(func=ipv6, args={'value': 'abc.0.0.1'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>IP address string to validate.</p> required <code>cidr</code> <code>bool</code> <p>IP address string may contain CIDR annotation.</p> <code>True</code> <code>strict</code> <code>bool</code> <p>IP address string is strictly in CIDR notation.</p> <code>False</code> <code>host_bit</code> <code>bool</code> <p>If <code>False</code> and host bits (along with network bits) are set in the supplied address, this function raises a validation error. ref IPv6Network.</p> <code>True</code> <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid IPv6 address.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid IPv6 address.</p> Source code in <code>src/validators/ip_address.py</code> <pre><code>@validator\ndef ipv6(value: str, /, *, cidr: bool = True, strict: bool = False, host_bit: bool = True):\n    \"\"\"Returns if a given value is a valid IPv6 address.\n\n    Including IPv4-mapped IPv6 addresses. The initial version of ipv6 validator\n    was inspired from [WTForms IPAddress validator][1].\n\n    [1]: https://github.com/wtforms/wtforms/blob/master/src/wtforms/validators.py\n\n    Examples:\n        &gt;&gt;&gt; ipv6('::ffff:192.0.2.128')\n        True\n        &gt;&gt;&gt; ipv6('::1/128')\n        True\n        &gt;&gt;&gt; ipv6('abc.0.0.1')\n        ValidationError(func=ipv6, args={'value': 'abc.0.0.1'})\n\n    Args:\n        value:\n            IP address string to validate.\n        cidr:\n            IP address string may contain CIDR annotation.\n        strict:\n            IP address string is strictly in CIDR notation.\n        host_bit:\n            If `False` and host bits (along with network bits) _are_ set in the supplied\n            address, this function raises a validation error. ref [IPv6Network][2].\n            [2]: https://docs.python.org/3/library/ipaddress.html#ipaddress.IPv6Network\n\n    Returns:\n        (Literal[True]): If `value` is a valid IPv6 address.\n        (ValidationError): If `value` is an invalid IPv6 address.\n    \"\"\"\n    if not value:\n        return False\n    try:\n        if cidr:\n            if strict and value.count(\"/\") != 1:\n                raise ValueError(\"IPv6 address was expected in CIDR notation\")\n            return IPv6Network(value, strict=not host_bit)\n        return IPv6Address(value)\n    except (ValueError, AddressValueError, NetmaskValueError):\n        return False\n</code></pre>"},{"location":"api/length/","title":"length","text":""},{"location":"api/length/#validators.length.length","title":"<code>validators.length.length(value, /, *, min_val=None, max_val=None)</code>","text":"<p>Return whether or not the length of given string is within a specified range.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; length('something', min_val=2)\nTrue\n&gt;&gt;&gt; length('something', min_val=9, max_val=9)\nTrue\n&gt;&gt;&gt; length('something', max_val=5)\nValidationError(func=length, args={'value': 'something', 'max_val': 5})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The string to validate.</p> required <code>min_val</code> <code>Union[int, None]</code> <p>The minimum required length of the string. If not provided, minimum length will not be checked.</p> <code>None</code> <code>max_val</code> <code>Union[int, None]</code> <p>The maximum length of the string. If not provided, maximum length will not be checked.</p> <code>None</code> <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>len(value)</code> is in between the given conditions.</p> <code>ValidationError</code> <p>If <code>len(value)</code> is not in between the given conditions.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If either <code>min_val</code> or <code>max_val</code> is negative.</p> Source code in <code>src/validators/length.py</code> <pre><code>@validator\ndef length(value: str, /, *, min_val: Union[int, None] = None, max_val: Union[int, None] = None):\n    \"\"\"Return whether or not the length of given string is within a specified range.\n\n    Examples:\n        &gt;&gt;&gt; length('something', min_val=2)\n        True\n        &gt;&gt;&gt; length('something', min_val=9, max_val=9)\n        True\n        &gt;&gt;&gt; length('something', max_val=5)\n        ValidationError(func=length, args={'value': 'something', 'max_val': 5})\n\n    Args:\n        value:\n            The string to validate.\n        min_val:\n            The minimum required length of the string. If not provided,\n            minimum length will not be checked.\n        max_val:\n            The maximum length of the string. If not provided,\n            maximum length will not be checked.\n\n    Returns:\n        (Literal[True]): If `len(value)` is in between the given conditions.\n        (ValidationError): If `len(value)` is not in between the given conditions.\n\n    Raises:\n        (ValueError): If either `min_val` or `max_val` is negative.\n    \"\"\"\n    if min_val is not None and min_val &lt; 0:\n        raise ValueError(\"Length cannot be negative. `min_val` is less than zero.\")\n    if max_val is not None and max_val &lt; 0:\n        raise ValueError(\"Length cannot be negative. `max_val` is less than zero.\")\n\n    return bool(between(len(value), min_val=min_val, max_val=max_val))\n</code></pre>"},{"location":"api/mac_address/","title":"mac_address","text":""},{"location":"api/mac_address/#validators.mac_address.mac_address","title":"<code>validators.mac_address.mac_address(value)</code>","text":"<p>Return whether or not given value is a valid MAC address.</p> <p>This validator is based on WTForms MacAddress validator.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; mac_address('01:23:45:67:ab:CD')\nTrue\n&gt;&gt;&gt; mac_address('00:00:00:00:00')\nValidationError(func=mac_address, args={'value': '00:00:00:00:00'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>MAC address string to validate.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid MAC address.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid MAC address.</p> Source code in <code>src/validators/mac_address.py</code> <pre><code>@validator\ndef mac_address(value: str, /):\n    \"\"\"Return whether or not given value is a valid MAC address.\n\n    This validator is based on [WTForms MacAddress validator][1].\n\n    [1]: https://github.com/wtforms/wtforms/blob/master/src/wtforms/validators.py#L482\n\n    Examples:\n        &gt;&gt;&gt; mac_address('01:23:45:67:ab:CD')\n        True\n        &gt;&gt;&gt; mac_address('00:00:00:00:00')\n        ValidationError(func=mac_address, args={'value': '00:00:00:00:00'})\n\n    Args:\n        value:\n            MAC address string to validate.\n\n    Returns:\n        (Literal[True]): If `value` is a valid MAC address.\n        (ValidationError): If `value` is an invalid MAC address.\n    \"\"\"\n    return re.match(r\"^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$\", value) if value else False\n</code></pre>"},{"location":"api/slug/","title":"slug","text":""},{"location":"api/slug/#validators.slug.slug","title":"<code>validators.slug.slug(value)</code>","text":"<p>Validate whether or not given value is valid slug.</p> <p>Valid slug can contain only lowercase alphanumeric characters and hyphens. It starts and ends with these lowercase alphanumeric characters.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; slug('my-slug-2134')\nTrue\n&gt;&gt;&gt; slug('my.slug')\nValidationError(func=slug, args={'value': 'my.slug'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Slug string to validate.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid slug.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid slug.</p> Source code in <code>src/validators/slug.py</code> <pre><code>@validator\ndef slug(value: str, /):\n    \"\"\"Validate whether or not given value is valid slug.\n\n    Valid slug can contain only lowercase alphanumeric characters and hyphens.\n    It starts and ends with these lowercase alphanumeric characters.\n\n    Examples:\n        &gt;&gt;&gt; slug('my-slug-2134')\n        True\n        &gt;&gt;&gt; slug('my.slug')\n        ValidationError(func=slug, args={'value': 'my.slug'})\n\n    Args:\n        value: Slug string to validate.\n\n    Returns:\n        (Literal[True]): If `value` is a valid slug.\n        (ValidationError): If `value` is an invalid slug.\n    \"\"\"\n    return re.match(r\"^[a-z0-9]+(?:-[a-z0-9]+)*$\", value) if value else False\n</code></pre>"},{"location":"api/url/","title":"url","text":""},{"location":"api/url/#validators.url.url","title":"<code>validators.url.url(value, /, *, skip_ipv6_addr=False, skip_ipv4_addr=False, may_have_port=True, simple_host=False, strict_query=True, consider_tld=False, private=None, rfc_1034=False, rfc_2782=False, validate_scheme=_validate_scheme)</code>","text":"<p>Return whether or not given value is a valid URL.</p> <p>This validator was originally inspired from URL validator of dperini. The following diagram is from urlly::</p> <pre><code>    foo://admin:hunter1@example.com:8042/over/there?name=ferret#nose\n    \\_/   \\___/ \\_____/ \\_________/ \\__/\\_________/ \\_________/ \\__/\n     |      |       |       |        |       |          |         |\n  scheme username password hostname port    path      query    fragment\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; url('http://duck.com')\nTrue\n&gt;&gt;&gt; url('ftp://foobar.dk')\nTrue\n&gt;&gt;&gt; url('http://10.0.0.1')\nTrue\n&gt;&gt;&gt; url('http://example.com/\"&gt;user@example.com')\nValidationError(func=url, args={'value': 'http://example.com/\"&gt;user@example.com'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>URL string to validate.</p> required <code>skip_ipv6_addr</code> <code>bool</code> <p>When URL string cannot contain an IPv6 address.</p> <code>False</code> <code>skip_ipv4_addr</code> <code>bool</code> <p>When URL string cannot contain an IPv4 address.</p> <code>False</code> <code>may_have_port</code> <code>bool</code> <p>URL string may contain port number.</p> <code>True</code> <code>simple_host</code> <code>bool</code> <p>URL string maybe only hyphens and alpha-numerals.</p> <code>False</code> <code>strict_query</code> <code>bool</code> <p>Fail validation on query string parsing error.</p> <code>True</code> <code>consider_tld</code> <code>bool</code> <p>Restrict domain to TLDs allowed by IANA.</p> <code>False</code> <code>private</code> <code>Optional[bool]</code> <p>Embedded IP address is public if <code>False</code>, private/local if <code>True</code>.</p> <code>None</code> <code>rfc_1034</code> <code>bool</code> <p>Allow trailing dot in domain/host name. Ref: RFC 1034.</p> <code>False</code> <code>rfc_2782</code> <code>bool</code> <p>Domain/Host name is of type service record. Ref: RFC 2782.</p> <code>False</code> <code>validate_scheme</code> <code>Callable[[str], bool]</code> <p>Function that validates URL scheme.</p> <code>_validate_scheme</code> <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid url.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid url.</p> Source code in <code>src/validators/url.py</code> <pre><code>@validator\ndef url(\n    value: str,\n    /,\n    *,\n    skip_ipv6_addr: bool = False,\n    skip_ipv4_addr: bool = False,\n    may_have_port: bool = True,\n    simple_host: bool = False,\n    strict_query: bool = True,\n    consider_tld: bool = False,\n    private: Optional[bool] = None,  # only for ip-addresses\n    rfc_1034: bool = False,\n    rfc_2782: bool = False,\n    validate_scheme: Callable[[str], bool] = _validate_scheme,\n):\n    r\"\"\"Return whether or not given value is a valid URL.\n\n    This validator was originally inspired from [URL validator of dperini][1].\n    The following diagram is from [urlly][2]::\n\n\n            foo://admin:hunter1@example.com:8042/over/there?name=ferret#nose\n            \\_/   \\___/ \\_____/ \\_________/ \\__/\\_________/ \\_________/ \\__/\n             |      |       |       |        |       |          |         |\n          scheme username password hostname port    path      query    fragment\n\n    [1]: https://gist.github.com/dperini/729294\n    [2]: https://github.com/treeform/urlly\n\n    Examples:\n        &gt;&gt;&gt; url('http://duck.com')\n        True\n        &gt;&gt;&gt; url('ftp://foobar.dk')\n        True\n        &gt;&gt;&gt; url('http://10.0.0.1')\n        True\n        &gt;&gt;&gt; url('http://example.com/\"&gt;user@example.com')\n        ValidationError(func=url, args={'value': 'http://example.com/\"&gt;user@example.com'})\n\n    Args:\n        value:\n            URL string to validate.\n        skip_ipv6_addr:\n            When URL string cannot contain an IPv6 address.\n        skip_ipv4_addr:\n            When URL string cannot contain an IPv4 address.\n        may_have_port:\n            URL string may contain port number.\n        simple_host:\n            URL string maybe only hyphens and alpha-numerals.\n        strict_query:\n            Fail validation on query string parsing error.\n        consider_tld:\n            Restrict domain to TLDs allowed by IANA.\n        private:\n            Embedded IP address is public if `False`, private/local if `True`.\n        rfc_1034:\n            Allow trailing dot in domain/host name.\n            Ref: [RFC 1034](https://www.rfc-editor.org/rfc/rfc1034).\n        rfc_2782:\n            Domain/Host name is of type service record.\n            Ref: [RFC 2782](https://www.rfc-editor.org/rfc/rfc2782).\n        validate_scheme:\n            Function that validates URL scheme.\n\n    Returns:\n        (Literal[True]): If `value` is a valid url.\n        (ValidationError): If `value` is an invalid url.\n    \"\"\"\n    if not value or re.search(r\"\\s\", value):\n        # url must not contain any white\n        # spaces, they must be encoded\n        return False\n\n    try:\n        scheme, netloc, path, query, fragment = urlsplit(value)\n    except ValueError:\n        return False\n\n    return (\n        validate_scheme(scheme)\n        and _validate_netloc(\n            netloc,\n            skip_ipv6_addr,\n            skip_ipv4_addr,\n            may_have_port,\n            simple_host,\n            consider_tld,\n            private,\n            rfc_1034,\n            rfc_2782,\n        )\n        and _validate_optionals(path, query, fragment, strict_query)\n    )\n</code></pre>"},{"location":"api/utils/","title":"utils","text":""},{"location":"api/utils/#validators.utils.ValidationError","title":"<code>validators.utils.ValidationError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception class when validation failure occurs.</p> Source code in <code>src/validators/utils.py</code> <pre><code>class ValidationError(Exception):\n    \"\"\"Exception class when validation failure occurs.\"\"\"\n\n    def __init__(self, function: Callable[..., Any], arg_dict: Dict[str, Any], message: str = \"\"):\n        \"\"\"Initialize Validation Failure.\"\"\"\n        if message:\n            self.reason = message\n        self.func = function\n        self.__dict__.update(arg_dict)\n\n    def __repr__(self):\n        \"\"\"Repr Validation Failure.\"\"\"\n        return (\n            f\"ValidationError(func={self.func.__name__}, \"\n            + f\"args={ ({k: v for (k, v) in self.__dict__.items() if k != 'func'}) })\"\n        )\n\n    def __str__(self):\n        \"\"\"Str Validation Failure.\"\"\"\n        return repr(self)\n\n    def __bool__(self):\n        \"\"\"Bool Validation Failure.\"\"\"\n        return False\n</code></pre>"},{"location":"api/utils/#validators.utils.ValidationError.__bool__","title":"<code>__bool__()</code>","text":"<p>Bool Validation Failure.</p> Source code in <code>src/validators/utils.py</code> <pre><code>def __bool__(self):\n    \"\"\"Bool Validation Failure.\"\"\"\n    return False\n</code></pre>"},{"location":"api/utils/#validators.utils.ValidationError.__init__","title":"<code>__init__(function, arg_dict, message='')</code>","text":"<p>Initialize Validation Failure.</p> Source code in <code>src/validators/utils.py</code> <pre><code>def __init__(self, function: Callable[..., Any], arg_dict: Dict[str, Any], message: str = \"\"):\n    \"\"\"Initialize Validation Failure.\"\"\"\n    if message:\n        self.reason = message\n    self.func = function\n    self.__dict__.update(arg_dict)\n</code></pre>"},{"location":"api/utils/#validators.utils.ValidationError.__repr__","title":"<code>__repr__()</code>","text":"<p>Repr Validation Failure.</p> Source code in <code>src/validators/utils.py</code> <pre><code>def __repr__(self):\n    \"\"\"Repr Validation Failure.\"\"\"\n    return (\n        f\"ValidationError(func={self.func.__name__}, \"\n        + f\"args={ ({k: v for (k, v) in self.__dict__.items() if k != 'func'}) })\"\n    )\n</code></pre>"},{"location":"api/utils/#validators.utils.ValidationError.__str__","title":"<code>__str__()</code>","text":"<p>Str Validation Failure.</p> Source code in <code>src/validators/utils.py</code> <pre><code>def __str__(self):\n    \"\"\"Str Validation Failure.\"\"\"\n    return repr(self)\n</code></pre>"},{"location":"api/utils/#validators.utils.validator","title":"<code>validators.utils.validator(func)</code>","text":"<p>A decorator that makes given function validator.</p> <p>Whenever the given <code>func</code> returns <code>False</code> this decorator returns <code>ValidationError</code> object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; @validator\n... def even(value):\n...     return not (value % 2)\n&gt;&gt;&gt; even(4)\nTrue\n&gt;&gt;&gt; even(5)\nValidationError(func=even, args={'value': 5})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., Any]</code> <p>Function which is to be decorated.</p> required <p>Returns:</p> Type Description <code>Callable[..., ValidationError | Literal[True]]</code> <p>A decorator which returns either <code>ValidationError</code> or <code>Literal[True]</code>.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If <code>r_ve</code> or <code>RAISE_VALIDATION_ERROR</code> is <code>True</code></p> Source code in <code>src/validators/utils.py</code> <pre><code>def validator(func: Callable[..., Any]):\n    \"\"\"A decorator that makes given function validator.\n\n    Whenever the given `func` returns `False` this\n    decorator returns `ValidationError` object.\n\n    Examples:\n        &gt;&gt;&gt; @validator\n        ... def even(value):\n        ...     return not (value % 2)\n        &gt;&gt;&gt; even(4)\n        True\n        &gt;&gt;&gt; even(5)\n        ValidationError(func=even, args={'value': 5})\n\n    Args:\n        func:\n            Function which is to be decorated.\n\n    Returns:\n        (Callable[..., ValidationError | Literal[True]]):\n            A decorator which returns either `ValidationError`\n            or `Literal[True]`.\n\n    Raises:\n        (ValidationError): If `r_ve` or `RAISE_VALIDATION_ERROR` is `True`\n    \"\"\"\n\n    @wraps(func)\n    def wrapper(*args: Any, **kwargs: Any):\n        raise_validation_error = False\n        if \"r_ve\" in kwargs:\n            raise_validation_error = True\n            del kwargs[\"r_ve\"]\n        if environ.get(\"RAISE_VALIDATION_ERROR\", \"False\") == \"True\":\n            raise_validation_error = True\n\n        try:\n            if raise_validation_error:\n                if func(*args, **kwargs):\n                    return True\n                else:\n                    raise ValidationError(func, _func_args_as_dict(func, *args, **kwargs))\n            else:\n                return (\n                    True\n                    if func(*args, **kwargs)\n                    else ValidationError(func, _func_args_as_dict(func, *args, **kwargs))\n                )\n        except (ValueError, TypeError, UnicodeError) as exp:\n            if raise_validation_error:\n                raise ValidationError(\n                    func, _func_args_as_dict(func, *args, **kwargs), str(exp)\n                ) from exp\n            else:\n                return ValidationError(func, _func_args_as_dict(func, *args, **kwargs), str(exp))\n\n    return wrapper\n</code></pre>"},{"location":"api/uuid/","title":"uuid","text":""},{"location":"api/uuid/#validators.uuid.uuid","title":"<code>validators.uuid.uuid(value)</code>","text":"<p>Return whether or not given value is a valid UUID-v4 string.</p> <p>This validator is based on WTForms UUID validator.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; uuid('2bc1c94f-0deb-43e9-92a1-4775189ec9f8')\nTrue\n&gt;&gt;&gt; uuid('2bc1c94f 0deb-43e9-92a1-4775189ec9f8')\nValidationError(func=uuid, args={'value': '2bc1c94f 0deb-43e9-92a1-4775189ec9f8'})\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Union[str, UUID]</code> <p>UUID string or object to validate.</p> required <p>Returns:</p> Type Description <code>Literal[True]</code> <p>If <code>value</code> is a valid UUID.</p> <code>ValidationError</code> <p>If <code>value</code> is an invalid UUID.</p> Source code in <code>src/validators/uuid.py</code> <pre><code>@validator\ndef uuid(value: Union[str, UUID], /):\n    \"\"\"Return whether or not given value is a valid UUID-v4 string.\n\n    This validator is based on [WTForms UUID validator][1].\n\n    [1]: https://github.com/wtforms/wtforms/blob/master/src/wtforms/validators.py#L539\n\n    Examples:\n        &gt;&gt;&gt; uuid('2bc1c94f-0deb-43e9-92a1-4775189ec9f8')\n        True\n        &gt;&gt;&gt; uuid('2bc1c94f 0deb-43e9-92a1-4775189ec9f8')\n        ValidationError(func=uuid, args={'value': '2bc1c94f 0deb-43e9-92a1-4775189ec9f8'})\n\n    Args:\n        value:\n            UUID string or object to validate.\n\n    Returns:\n        (Literal[True]): If `value` is a valid UUID.\n        (ValidationError): If `value` is an invalid UUID.\n    \"\"\"\n    if not value:\n        return False\n    if isinstance(value, UUID):\n        return True\n    try:\n        return UUID(value) or re.match(\n            r\"^[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}$\", value\n        )\n    except ValueError:\n        return False\n</code></pre>"}]}